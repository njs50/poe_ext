ITEM_TYPE_DATA = {
	"Crude Bow": "weapon2h",
	"Short Bow": "weapon2h",
	"Long Bow": "weapon2h",
	"Composite Bow": "weapon2h",
	"Recurve Bow": "weapon2h",
	"Bone Bow": "weapon2h",
	"Royal Bow": "weapon2h",
	"Death Bow": "weapon2h",
	"Grove Bow": "weapon2h",
	"Decurve Bow": "weapon2h",
	"Compound Bow": "weapon2h",
	"Sniper Bow": "weapon2h",
	"Ivory Bow": "weapon2h",
	"Highborn Bow": "weapon2h",
	"Decimation Bow": "weapon2h",
	"Thicket Bow": "weapon2h",
	"Citadel Bow": "weapon2h",
	"Ranger Bow": "weapon2h",
	"Maraketh Bow": "weapon2h",
	"Spine Bow": "weapon2h",
	"Imperial Bow": "weapon2h",
	"Harbinger Bow": "weapon2h",
	"Nailed Fist": "weapon1h",
	"Sharktooth Claw": "weapon1h",
	"Awl": "weapon1h",
	"Cat's Paw": "weapon1h",
	"Blinder": "weapon1h",
	"Timeworn Claw": "weapon1h",
	"Sparkling Claw": "weapon1h",
	"Fright Claw": "weapon1h",
	"Thresher Claw": "weapon1h",
	"Gouger": "weapon1h",
	"Tiger's Paw": "weapon1h",
	"Gut Ripper": "weapon1h",
	"Prehistoric Claw": "weapon1h",
	"Noble Claw": "weapon1h",
	"Eagle Claw": "weapon1h",
	"Great White Claw": "weapon1h",
	"Throat Stabber": "weapon1h",
	"Hellion's Paw": "weapon1h",
	"Eye Gouger": "weapon1h",
	"Vaal Claw": "weapon1h",
	"Imperial Claw": "weapon1h",
	"Terror Claw": "weapon1h",
	"Glass Shank": "weapon1h",
	"Skinning Knife": "weapon1h",
	"Carving Knife": "weapon1h",
	"Stiletto": "weapon1h",
	"Boot Knife": "weapon1h",
	"Copper Kris": "weapon1h",
	"Skean": "weapon1h",
	"Imp Dagger": "weapon1h",
	"Flaying Knife": "weapon1h",
	"Butcher Knife": "weapon1h",
	"Poignard": "weapon1h",
	"Boot Blade": "weapon1h",
	"Golden Kris": "weapon1h",
	"Royal Skean": "weapon1h",
	"Fiend Dagger": "weapon1h",
	"Gutting Knife": "weapon1h",
	"Slaughter Knife": "weapon1h",
	"Ambusher": "weapon1h",
	"Ezomyte Dagger": "weapon1h",
	"Platinum Kris": "weapon1h",
	"Imperial Skean": "weapon1h",
	"Demon Dagger": "weapon1h",
	"Rusted Hatchet": "weapon1h",
	"Jade Hatchet": "weapon1h",
	"Boarding Axe": "weapon1h",
	"Cleaver": "weapon1h",
	"Broad Axe": "weapon1h",
	"Arming Axe": "weapon1h",
	"Decorative Axe": "weapon1h",
	"Spectral Axe": "weapon1h",
	"Jasper Axe": "weapon1h",
	"Tomahawk": "weapon1h",
	"Wrist Chopper": "weapon1h",
	"War Axe": "weapon1h",
	"Chest Splitter": "weapon1h",
	"Ceremonial Axe": "weapon1h",
	"Wraith Axe": "weapon1h",
	"Karui Axe": "weapon1h",
	"Siege Axe": "weapon1h",
	"Reaver Axe": "weapon1h",
	"Ezomyte Axe": "weapon1h",
	"Vaal Hatchet": "weapon1h",
	"Royal Axe": "weapon1h",
	"Infernal Axe": "weapon1h",
	"Driftwood Club": "weapon1h",
	"Tribal Club": "weapon1h",
	"Spiked Club": "weapon1h",
	"Stone Hammer": "weapon1h",
	"War Hammer": "weapon1h",
	"Bladed Mace": "weapon1h",
	"Ceremonial Mace": "weapon1h",
	"Dream Mace": "weapon1h",
	"Petrified Club": "weapon1h",
	"Barbed Club": "weapon1h",
	"Rock Breaker": "weapon1h",
	"Battle Hammer": "weapon1h",
	"Flanged Mace": "weapon1h",
	"Ornate Mace": "weapon1h",
	"Phantom Mace": "weapon1h",
	"Ancestral Club": "weapon1h",
	"Tenderizer": "weapon1h",
	"Gavel": "weapon1h",
	"Legion Hammer": "weapon1h",
	"Pernarch": "weapon1h",
	"Auric Mace": "weapon1h",
	"Nightmare Mace": "weapon1h",
	"Rusted Sword": "weapon1h",
	"Copper Sword": "weapon1h",
	"Sabre": "weapon1h",
	"Broad Sword": "weapon1h",
	"War Sword": "weapon1h",
	"Ancient Sword": "weapon1h",
	"Elegant Sword": "weapon1h",
	"Dusk Blade": "weapon1h",
	"Variscite Blade": "weapon1h",
	"Cutlass": "weapon1h",
	"Baselard": "weapon1h",
	"Battle Sword": "weapon1h",
	"Elder Sword": "weapon1h",
	"Graceful Sword": "weapon1h",
	"Twilight Blade": "weapon1h",
	"Gemstone Sword": "weapon1h",
	"Corsair Sword": "weapon1h",
	"Gladius": "weapon1h",
	"Legion Sword": "weapon1h",
	"Vaal Blade": "weapon1h",
	"Eternal Sword": "weapon1h",
	"Midnight Blade": "weapon1h",
	"Driftwood Sceptre": "weapon1h",
	"Darkwood Sceptre": "weapon1h",
	"Bronze Sceptre": "weapon1h",
	"Quartz Sceptre": "weapon1h",
	"Iron Sceptre": "weapon1h",
	"Ochre Sceptre": "weapon1h",
	"Ritual Sceptre": "weapon1h",
	"Shadow Sceptre": "weapon1h",
	"Grinning Fetish": "weapon1h",
	"Sekhem": "weapon1h",
	"Crystal Sceptre": "weapon1h",
	"Lead Sceptre": "weapon1h",
	"Blood Sceptre": "weapon1h",
	"Royal Sceptre": "weapon1h",
	"Abyssal Sceptre": "weapon1h",
	"Karui Sceptre": "weapon1h",
	"Tyrant's Sekhem": "weapon1h",
	"Opal Sceptre": "weapon1h",
	"Platinum Sceptre": "weapon1h",
	"Carnal Sceptre": "weapon1h",
	"Vaal Sceptre": "weapon1h",
	"Void Sceptre": "weapon1h",
	"Gnarled Branch": "weapon2h",
	"Primitive Staff": "weapon2h",
	"Long Staff": "weapon2h",
	"Iron Staff": "weapon2h",
	"Coiled Staff": "weapon2h",
	"Royal Staff": "weapon2h",
	"Vile Staff": "weapon2h",
	"Woodful Staff": "weapon2h",
	"Quarterstaff": "weapon2h",
	"Military Staff": "weapon2h",
	"Serpentine Staff": "weapon2h",
	"Highborn Staff": "weapon2h",
	"Foul Staff": "weapon2h",
	"Primordial Staff": "weapon2h",
	"Lathi": "weapon2h",
	"Ezoymte Staff": "weapon2h",
	"Maelstr\u00F6m Staff": "weapon2h",
	"Imperial Staff": "weapon2h",
	"Damnation Staff": "weapon2h",
	"Ezomyte Staff": "weapon2h",
	"Rusted Spike": "weapon1h",
	"Whalebone Rapier": "weapon1h",
	"Battered Foil": "weapon1h",
	"Basket Rapier": "weapon1h",
	"Jagged Foil": "weapon1h",
	"Antique Rapier": "weapon1h",
	"Elegant Foil": "weapon1h",
	"Thorn Rapier": "weapon1h",
	"Wyrmbone Rapier": "weapon1h",
	"Burnished Foil": "weapon1h",
	"Estoc": "weapon1h",
	"Serrated Foil": "weapon1h",
	"Primeval Rapier": "weapon1h",
	"Fancy Foil": "weapon1h",
	"Apex Rapier": "weapon1h",
	"Dragonbone Rapier": "weapon1h",
	"Tempered Foil": "weapon1h",
	"Pecoraro": "weapon1h",
	"Spiraled Foil": "weapon1h",
	"Vaal Rapier": "weapon1h",
	"Jeweled Foil": "weapon1h",
	"Harpy Rapier": "weapon1h",
	"Stone Axe": "weapon2h",
	"Jade Chopper": "weapon2h",
	"Woodsplitter": "weapon2h",
	"Poleaxe": "weapon2h",
	"Double Axe": "weapon2h",
	"Gilded Axe": "weapon2h",
	"Shadow Axe": "weapon2h",
	"Jasper Chopper": "weapon2h",
	"Timber Axe": "weapon2h",
	"Headsman Axe": "weapon2h",
	"Labrys": "weapon2h",
	"Noble Axe": "weapon2h",
	"Abyssal Axe": "weapon2h",
	"Karui Chopper": "weapon2h",
	"Sundering Axe": "weapon2h",
	"Ezomyte Axe": "weapon2h",
	"Vaal Axe": "weapon2h",
	"Despot Axe": "weapon2h",
	"Void Axe": "weapon2h",
	"Driftwood Maul": "weapon2h",
	"Tribal Maul": "weapon2h",
	"Mallet": "weapon2h",
	"Sledgehammer": "weapon2h",
	"Spiked Maul": "weapon2h",
	"Brass Maul": "weapon2h",
	"Fright Maul": "weapon2h",
	"Totemic Maul": "weapon2h",
	"Great Mallet": "weapon2h",
	"Steelhead": "weapon2h",
	"Spiny Maul": "weapon2h",
	"Plated Maul": "weapon2h",
	"Dread Maul": "weapon2h",
	"Karui Maul": "weapon2h",
	"Colossus Mallet": "weapon2h",
	"Piledriver": "weapon2h",
	"Meatgrinder": "weapon2h",
	"Imperial Maul": "weapon2h",
	"Terror Maul": "weapon2h",
	"Corroded Blade": "weapon2h",
	"Longsword": "weapon2h",
	"Bastard Sword": "weapon2h",
	"Two-Handed Sword": "weapon2h",
	"Etched Greatsword": "weapon2h",
	"Ornate Sword": "weapon2h",
	"Spectral Sword": "weapon2h",
	"Butcher Sword": "weapon2h",
	"Footman Sword": "weapon2h",
	"Highland Blade": "weapon2h",
	"Engraved Greatsword": "weapon2h",
	"Tiger Sword": "weapon2h",
	"Wraith Sword": "weapon2h",
	"Headman's Sword": "weapon2h",
	"Reaver Sword": "weapon2h",
	"Ezomyte Blade": "weapon2h",
	"Vaal Greatsword": "weapon2h",
	"Lion Sword": "weapon2h",
	"Infernal Sword": "weapon2h",
	"Driftwood Wand": "weapon1h",
	"Goat's Horn": "weapon1h",
	"Carved Wand": "weapon1h",
	"Quartz Wand": "weapon1h",
	"Spiraled Wand": "weapon1h",
	"Sage Wand": "weapon1h",
	"Faun's Horn": "weapon1h",
	"Engraved Wand": "weapon1h",
	"Crystal Wand": "weapon1h",
	"Serpent Wand": "weapon1h",
	"Omen Wand": "weapon1h",
	"Demon's Horn": "weapon1h",
	"Imbued Wand": "weapon1h",
	"Opal Wand": "weapon1h",
	"Tornado Wand": "weapon1h",
	"Prophecy Wand": "weapon1h",
	"Plate Vest": "chest",
	"Shabby Jerkin": "chest",
	"Simple Robe": "chest",
	"Scale Vest": "chest",
	"Padded Vest": "chest",
	"Chainmail Vest": "chest",
	"Chestplate": "chest",
	"Light Brigandine": "chest",
	"Desert Brigandine": "chest",
	"Legion Brigandine": "chest",
	"Chainmail Tunic": "chest",
	"Strapped Leather": "chest",
	"Oiled Vest": "chest",
	"Silken Vest": "chest",
	"Buckskin Tunic": "chest",
	"Copper Plate": "chest",
	"Ringmail Coat": "chest",
	"Scale Doublet": "chest",
	"Scholar's Robe": "chest",
	"Diplomatic Robe": "chest",
	"Robe": "chest",
	"Duelist Cuirass": "chest",
	"Ringmail": "chest",
	"Padded Jacket": "chest",
	"Infantry Brigandine": "chest",
	"War Plate": "chest",
	"Chainmail Doublet": "chest",
	"Oiled Coat": "chest",
	"Silken Garb": "chest",
	"Wild Leather": "chest",
	"Scarlet Raiment": "chest",
	"Full Ringmail": "chest",
	"Full Scale Armor": "chest",
	"Full Scale Armour": "chest",
	"Mage's Vestment": "chest",
	"Full Leather": "chest",
	"Full Plate": "chest",
	"Arena Plate": "chest",
	"Sun Leather": "chest",
	"Silk Robe": "chest",
	"Soldier's Brigandine": "chest",
	"Soldier Brigandine": "chest",
	"Full Chainmail": "chest",
	"Waxed Garb": "chest",
	"Thief's Garb": "chest",
	"Bone Armor": "chest",
	"Bone Armour": "chest",
	"Lordly Plate": "chest",
	"Field Lamellar": "chest",
	"Cabalist Regalia": "chest",
	"Holy Chainmail": "chest",
	"Eelskin Tunic": "chest",
	"Sage's Robe": "chest",
	"Bronze Plate": "chest",
	"Wyrmscale Doublet": "chest",
	"Latticed Ringmail": "chest",
	"Quilted Jacket": "chest",
	"Battle Plate": "chest",
	"Silken Wrap": "chest",
	"Frontier Leather": "chest",
	"Hussar Brigandine": "chest",
	"Crusader Chainmail": "chest",
	"Sleek Coat": "chest",
	"Conjurer's Vestment": "chest",
	"Glorious Leather": "chest",
	"Sun Plate": "chest",
	"Full Wyrmscale": "chest",
	"Ornate Ringmail": "chest",
	"Crimson Raiment": "chest",
	"Coronal Leather": "chest",
	"Colosseum Plate": "chest",
	"Spidersilk Robe": "chest",
	"Commander's Brigandine": "chest",
	"Chain Hauberk": "chest",
	"Lacquered Garb": "chest",
	"Cutthroat's Garb": "chest",
	"Destroyer Regalia": "chest",
	"Majestic Plate": "chest",
	"Battle Lamellar": "chest",
	"Devout Chainmail": "chest",
	"Golden Plate": "chest",
	"Leather Tunic": "chest",
	"Salvation Robe": "chest",
	"Strapped Leathers": "chest",
	"Sharkskin Tunic": "chest",
	"Savant's Robe": "chest",
	"Crypt Armor": "chest",
	"Crypt Armour": "chest",
	"Dragonscale Doublet": "chest",
	"Loricated Ringmail": "chest",
	"Sentinel Jacket": "chest",
	"Destiny Leather": "chest",
	"Crusader Plate": "chest",
	"Necromancer Silks": "chest",
	"Cavalry Brigandine": "chest",
	"Conquest Chainmail": "chest",
	"Astral Plate": "chest",
	"Varnished Coat": "chest",
	"Occultist's Vestment": "chest",
	"Exquisite Leather": "chest",
	"Full Dragonscale": "chest",
	"Elegant Ringmail": "chest",
	"Gladiator Plate": "chest",
	"Blood Raiment": "chest",
	"Widowsilk Robe": "chest",
	"Zodiac Leather": "chest",
	"General's Brigandine": "chest",
	"Saint's Hauberk": "chest",
	"Glorious Plate": "chest",
	"Assassin's Garb": "chest",
	"Sadist Garb": "chest",
	"Vaal Regalia": "chest",
	"Triumphant Lamellar": "chest",
	"Saintly Chainmail": "chest",
	"Carnal Armor": "chest",
	"Carnal Armour": "chest",
	"Iron Greaves": "feet",
	"Rawhide Boots": "feet",
	"Wool Shoes": "feet",
	"Chain Boots": "feet",
	"Wrapped Boots": "feet",
	"Leatherscale Boots": "feet",
	"Velvet Slippers": "feet",
	"Steel Greaves": "feet",
	"Goathide Boots": "feet",
	"Ringmail Boots": "feet",
	"Strapped Boots": "feet",
	"Ironscale Boots": "feet",
	"Deerskin Boots": "feet",
	"Silk Slippers": "feet",
	"Plated Greaves": "feet",
	"Clasped Boots": "feet",
	"Mesh Boots": "feet",
	"Bronzescale Boots": "feet",
	"Scholar Boots": "feet",
	"Reinforced Greaves": "feet",
	"Nubuck Boots": "feet",
	"Shackled Boots": "feet",
	"Steelscale Boots": "feet",
	"Riveted Boots": "feet",
	"Antique Greaves": "feet",
	"Satin Slippers": "feet",
	"Eelskin Boots": "feet",
	"Zealot Boots": "feet",
	"Trapper Boots": "feet",
	"Serpentscale Boots": "feet",
	"Samite Slippers": "feet",
	"Sharkskin Boots": "feet",
	"Ancient Greaves": "feet",
	"Ambush Boots": "feet",
	"Horseman's Boots": "feet",
	"Soldier's Boots": "feet",
	"Soldier Boots": "feet",
	"Legion Boots": "feet",
	"Wyrmscale Boots": "feet",
	"Conjurer Boots": "feet",
	"Goliath Greaves": "feet",
	"Shagreen Boots": "feet",
	"Carnal Boots": "feet",
	"Desert Boots": "feet",
	"Legion Boots": "feet",
	"Hydrascale Boots": "feet",
	"Arcanist Slippers": "feet",
	"Vaal Greaves": "feet",
	"Stealth Boots": "feet",
	"Assassin's Boots": "feet",
	"Crusader Boots": "feet",
	"Dragonscale Boots": "feet",
	"Sorcerer Boots": "feet",
	"Titan Greaves": "feet",
	"Murder Boots": "feet",
	"Slink Boots": "feet",
	"Iron Gauntlets": "hands",
	"Wool Gloves": "hands",
	"Rawhide Gloves": "hands",
	"Fishscale Gauntlets": "hands",
	"Wrapped Mitts": "hands",
	"Chain Gloves": "hands",
	"Goathide Gloves": "hands",
	"Plated Gauntlets": "hands",
	"Velvet Gloves": "hands",
	"Ironscale Gauntlets": "hands",
	"Strapped Mitts": "hands",
	"Ringmail Gloves": "hands",
	"Deerskin Gloves": "hands",
	"Bronze Gauntlets": "hands",
	"Silk Gloves": "hands",
	"Bronzescale Gauntlets": "hands",
	"Clasped Mitts": "hands",
	"Mesh Gloves": "hands",
	"Nubuck Gloves": "hands",
	"Steel Gauntlets": "hands",
	"Steelscale Gauntlets": "hands",
	"Embroidered Gloves": "hands",
	"Trapper Mitts": "hands",
	"Riveted Gloves": "hands",
	"Eelskin Gloves": "hands",
	"Antique Gauntlets": "hands",
	"Satin Gloves": "hands",
	"Zealot Gloves": "hands",
	"Serpentscale Gauntlets": "hands",
	"Sharkskin Gloves": "hands",
	"Ambush Mitts": "hands",
	"Samite Gloves": "hands",
	"Ancient Gauntlets": "hands",
	"Wyrmscale Gauntlets": "hands",
	"Carnal Mitts": "hands",
	"Horseman's Gloves": "hands",
	"Soldier's Gloves": "hands",
	"Soldier Gloves": "hands",
	"Legion Gloves": "hands",
	"Goliath Gauntlets": "hands",
	"Shagreen Gloves": "hands",
	"Conjurer Gloves": "hands",
	"Cavalry Gloves": "hands",
	"Assassin's Mitts": "hands",
	"Hydrascale Gauntlets": "hands",
	"Arcanist Gloves": "hands",
	"Stealth Gloves": "hands",
	"Vaal Gauntlets": "hands",
	"Crusader Gloves": "hands",
	"Dragonscale Gauntlets": "hands",
	"Murder Mitts": "hands",
	"Titan Gauntlets": "hands",
	"Sorcerer Gloves": "hands",
	"Slink Gloves": "hands",
	"Rusted Casque": "head",
	"Vine Circlet": "head",
	"Battered Cap": "head",
	"Tarnished Mask": "head",
	"Rusted Helmet": "head",
	"Corroded Chain Coif": "head",
	"Footman's Casque": "head",
	"Copper Circlet": "head",
	"Wooden Mask": "head",
	"Leather Cap": "head",
	"Chainmail Coif": "head",
	"Flanged Helmet": "head",
	"Tribal Circlet": "head",
	"Copper Mask": "head",
	"Gladiator Casque": "head",
	"Leather Hood": "head",
	"Ringmail Coif": "head",
	"Ribbed Helmet": "head",
	"Executioner Casque": "head",
	"Gemmed Circlet": "head",
	"Ceremonial Mask": "head",
	"Studded Hood": "head",
	"Inlaid Chain Coif": "head",
	"Gilded Helmet": "head",
	"Gilded Circlet": "head",
	"Bandit Mask": "head",
	"Imperial Casque": "head",
	"Coolus Helmet": "head",
	"Woven Ring Coif": "head",
	"Iron Mask": "head",
	"Carved Circlet": "head",
	"Reaver Casque": "head",
	"Hunter Cap": "head",
	"Finned Helmet": "head",
	"Mesh Chain Coif": "head",
	"Heathen Mask": "head",
	"Forest Hood": "head",
	"Encrusted Circlet": "head",
	"Mercenary Casque": "head",
	"Ornate Helmet": "head",
	"Assassin Mask": "head",
	"Zealot's Chain Coif": "head",
	"Gleaming Circlet": "head",
	"Grove Hood": "head",
	"Vaal Casque": "head",
	"Steel Mask": "head",
	"Commander's Ring Coif": "head",
	"Polished Helmet": "head",
	"Petrified Circlet": "head",
	"Destroyer Casque": "head",
	"Huntress Cap": "head",
	"Pagan Mask": "head",
	"Crusader's Chain Coif": "head",
	"Bladed Helmet": "head",
	"Thicket Hood": "head",
	"Annihilator Casque": "head",
	"Royal Circlet": "head",
	"Crested Helmet": "head",
	"Murder Mask": "head",
	"Imperial Chain Coif": "head",
	"Ezomyte Circlet": "head",
	"Armageddon Casque": "head",
	"Jungle Hood": "head",
	"Splintered Tower Shield": "shield",
	"Goathide Buckler": "shield",
	"Twig Spirit Shield": "shield",
	"Rotted Round Shield": "shield",
	"Corroded Tower Shield": "shield",
	"Spiked Bundle": "shield",
	"Plank Kite Shield": "shield",
	"Pine Buckler": "shield",
	"Yew Spirit Shield": "shield",
	"Rawhide Tower Shield": "shield",
	"Driftwood Spiked Shield": "shield",
	"Fir Round Shield": "shield",
	"Linden Kite Shield": "shield",
	"Bone Spirit Shield": "shield",
	"Painted Buckler": "shield",
	"Cedar Tower Shield": "shield",
	"Alloyed Spike Shield": "shield",
	"Studded Round Shield": "shield",
	"Reinforced Kite Shield": "shield",
	"Hammered Buckler": "shield",
	"Tarnished Spirit Shield": "shield",
	"Copper Tower Shield": "shield",
	"Burnished Spike Shield": "shield",
	"Layered Kite Shield": "shield",
	"Scarlet Round Shield": "shield",
	"Jingling Spirit Shield": "shield",
	"War Buckler": "shield",
	"Reinforced Tower Shield": "shield",
	"Ornate Spiked Shield": "shield",
	"Brass Spirit Shield": "shield",
	"Splendid Round Shield": "shield",
	"Gilded Buckler": "shield",
	"Ceremonial Kite Shield": "shield",
	"Painted Tower Shield": "shield",
	"Walnut Spirit Shield": "shield",
	"Oak Buckler": "shield",
	"Redwood Spiked Shield": "shield",
	"Maple Round Shield": "shield",
	"Buckskin Tower Shield": "shield",
	"Etched Shield": "shield",
	"Ivory Spirit Shield": "shield",
	"Enameled Buckler": "shield",
	"Mahogany Tower Shield": "shield",
	"Ancient Spirit Shield": "shield",
	"Compound Spiked Shield": "shield",
	"Spiked Round Shield": "shield",
	"Corrugated Buckler": "shield",
	"Steel Kite Shield": "shield",
	"Bronze Tower Shield": "shield",
	"Chiming Spirit Shield": "shield",
	"Polished Spiked Shield": "shield",
	"Crimson Round Shield": "shield",
	"Laminated Kite Shield": "shield",
	"Battle Buckler": "shield",
	"Salvaged Buckler": "shield",
	"Girded Tower Shield": "shield",
	"Thorium Spirit Shield": "shield",
	"Sovereign Spiked Shield": "shield",
	"Baroque Round Shield": "shield",
	"Golden Buckler": "shield",
	"Angel Kite Shield": "shield",
	"Angelic Kite Shield": "shield",
	"Crested Tower Shield": "shield",
	"Lacewood Spirit Shield": "shield",
	"Ironwood Buckler": "shield",
	"Shagreen Tower Shield": "shield",
	"Teak Round Shield": "shield",
	"Alder Spike Shield": "shield",
	"Fossilized Spirit Shield": "shield",
	"Branded Kite Shield": "shield",
	"Lacquered Buckler": "shield",
	"Hunting Shield": "shield",
	"Ebony Tower Shield": "shield",
	"Ezomyte Spiked Shield": "shield",
	"Vaal Spirit Shield": "shield",
	"Spiny Round Shield": "shield",
	"Champion Kite Shield": "shield",
	"Vaal Buckler": "shield",
	"Ezomyte Tower Shield": "shield",
	"Harmonic Spirit Shield": "shield",
	"Mosaic Kite Shield": "shield",
	"Mirrored Spiked Shield": "shield",
	"Crusader Buckler": "shield",
	"Cardinal Round Shield": "shield",
	"Colossal Tower Shield": "shield",
	"Archon Kite Shield": "shield",
	"Titanium Spirit Shield": "shield",
	"Wood Focus": "shield",
	"Tribal Kite Shield": "shield",
	"Salvaged Shield": "shield",
	"Bone Focus": "shield",
	"Driftwood Shield": "shield",
	"Imperial Buckler": "shield",
	"Elegant Round Shield": "shield",
	"Supreme Spiked Shield": "shield",
	"Pinnacle Tower Shield": "shield",
	"Paua Amulet": "amulet",
	"Coral Amulet": "amulet",
	"Jade Amulet": "amulet",
	"Amber Amulet": "amulet",
	"Lapis Amulet": "amulet",
	"Gold Amulet": "amulet",
	"Onyx Amulet": "amulet",
	"Chain Belt": "belt",
	"Rustic Sash": "belt",
	"Leather Belt": "belt",
	"Heavy Belt": "belt",
	"Studded Belt": "belt",
	"Cloth Belt": "belt",
	"Coral Ring": "ring",
	"Prismatic Ring": "ring",
	"Paua Ring": "ring",
	"Iron Ring": "ring",
	"Sapphire Ring": "ring",
	"Gold Ring": "ring",
	"Ruby Ring": "ring",
	"Topaz Ring": "ring",
	"Conductive Quiver": "quiver",
	"Cured Quiver": "quiver",
	"Arachnid Nest Map": "map",
	"Bog Map": "map",
	"Canyon Map": "map",
	"Catacomb Map": "map",
	"Cells Map": "map",
	"Cemetery Map": "map",
	"Coves Map": "map",
	"Crematorium Map": "map",
	"Crypt Map": "map",
	"Dark Forest Map": "map",
	"Dried Lake Map": "map",
	"Dry Peninsula Map": "map",
	"Dry Woods Map": "map",
	"Dunes Map": "map",
	"Dungeon Map": "map",
	"Gorge Map": "map",
	"Graveyard Map": "map",
	"Arcade Map": "map",
	"Ghetto Map": "map",
	"Grotto Map": "map",
	"Jungle Valley Map": "map",
	"Marsh Map": "map",
	"Maze Map": "map",
	"Mine Map": "map",
	"Mountain Ledge Map": "map",
	"Mud Geyser Map": "map",
	"Necropolis Map": "map",
	"Overgrown Ruin Map": "map",
	"Overgrown Shrine Map": "map",
	"Plateau Map": "map",
	"Reef Map": "map",
	"Sewer Map": "map",
	"Shore Map": "map",
	"Spider Forest Map": "map",
	"Spider Lair Map": "map",
	"Springs Map": "map",
	"Strand Map": "map",
	"Subterranean Stream Map": "map",
	"Thicket Map": "map",
	"Tomb Map": "map",
	"Torture Chamber Map": "map",
	"Tropical Island Map": "map",
	"Tunnel Map": "map",
	"Underground River Map": "map",
	"Underground Sea Map": "map",
	"Vaal Pyramid Map": "map",
	"Vaults of Atziri Map": "map",
	"Waste Pool Map": "map"
};

CURRENCY_DATA = {
		"Alchemy Shard" : "alchemyShard",
		"Alteration Shard" : "alterationShard",
		"Scroll Fragment" : "scrollFragment",
		"Armourer's Scrap" : "armourScrap",
		"Blacksmith's Whetstone" : "blacksmithWhetstone",
		"Blessed Orb" : "blessedOrb",
		"Chaos Orb" : "chaosOrb",
		"Chromatic Orb" : "chromaticOrb",
		"Divine Orb" : "divineOrb",
		"Exalted Orb" : "exaltedOrb",
		"Gemcutter's Prism" : "GCP",
		"Glassblower's Bauble" : "bauble",
		"Jeweller's Orb" : "jewelersOrb",
		"Mirror of Kalandra" : "mirrorOfKalandra",
		"Orb of Alchemy" : "alchemyOrb",
		"Orb of Alteration" : "alterationOrb",
		"Orb of Augmentation": "augmentationOrb",
		"Orb of Chance" : "chanceOrb",
		"Orb of Fusing" : "fusingOrb",
		"Orb of Regret" : "regretOrb",
		"Orb of Scouring" : "scouringOrb",
		"Orb of Transmutation" : "transmutationOrb",
		"Portal Scroll" : "portalScroll",
		"Regal Orb" : "regalOrb",
		"Scroll of Wisdom" : "wisdomScroll",
		"Transmutation Shard" : "transmutationShard",
		"The Apex": 'questItem',
		"Baleful Gem": 'questItem',
		"Glyph": 'questItem',
		"Medicine Chest": 'questItem',
		"Maligaro's Spike": 'questItem',
		"Golden Hand": 'questItem',
		"Sewer Keys": 'questItem',
		"Alira's Amulet": 'questItem',
		"Kraityn's Amulet": 'questItem',
		"Oak's Amulet": 'questItem',
		"Allflame": 'questItem',
		"Thaumetic Sulphite": 'questItem',
		"Cartographer's Chisel": 'cartographerChisel'
}

var cache_enabled = true;

window.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;



const db_name = "poe_plus";
const store_name = "cache";
const db_version = 3;

var tx_readonly = 'readonly';
var tx_readwrite = 'readwrite';

function initCache(){

	var deferred = new $.Deferred();
console.log("Cache inited...");
	if (window.indexedDB === undefined) {
		console.log("IndexedDB support not detected, disabling caching...");
		cache_enabled = false;
		deferred.resolve();
		return deferred.promise();

	}

	var request = window.indexedDB.open(db_name,db_version);

	request.onupgradeneeded = function(e) {

		db = request.result;

		var txn = e.target.result;

		if(db.objectStoreNames.contains(store_name)) {
			db.deleteObjectStore(store_name);
		}

		db.createObjectStore(store_name);

		txn.oncomplete = function () {
			// console.log('new store created');
			deferred.resolve();

        }
	};

	request.onsuccess = function(e) {

	console.log('indexed db opened');

		db = request.result;

		if (db.version != db_version) {

			console.log('indexed db version incorrect');

			var setVrequest = db.setVersion(db_version);

            // onsuccess is the only place we can create Object Stores
            setVrequest.onfailure = function(e){
            	console.log('error setting version');
            };

            setVrequest.onsuccess = function(e) {

				var txn = e.target.result;

				if(db.objectStoreNames.contains(store_name)) {
					db.deleteObjectStore(store_name);
				}

				db.createObjectStore(store_name);

				txn.oncomplete = function () {
			console.log('new store created');
					deferred.resolve();

                }

            };



		} else {
			deferred.resolve();
		}

	};

	request.onerror = function(e){
		console.log("Failed to open indexed DB, disabling caching... : " + e);
		cache_enabled = false;
		deferred.resolve();
	};

	return deferred.promise();
}


function resetCache(callback) {

	if (cache_enabled){

		var request = db.transaction([store_name], tx_readwrite).objectStore(store_name).clear();

		request.onsuccess = function(e) {
		console.log('db reset');
			if(jQuery.isFunction(callback)) callback();
		};

		request.onerror = function(e){
			console.log('Error clearing cache DB');
			cache_enabled = false;
			console.log(e);
			// continue on with cache disabled....
			if(jQuery.isFunction(callback)) callback();
		};

	}

}



function getCache(cacheName) {

	var deferred = new $.Deferred();
					
		
	if (cache_enabled){

		var request = db.transaction([store_name], tx_readonly).objectStore(store_name).get(cacheName);

		request.onsuccess = function(e) {
		    if (typeof request.result == 'undefined'){
		    	deferred.reject();
		    } else {
		    	console.log('Success getting cache:' + cacheName );
		    	deferred.resolve(request.result);
		    }
		};

		request.onerror = function(e){
			console.log('Error getting object from cache');
			cache_enabled = false;
			console.log(e);
			deferred.reject();
		};

	} else deferred.reject();

	return deferred.promise();

}

function removeFromCache(cacheName) {

	var deferred = new $.Deferred();

	if (cache_enabled){

		var request = db.transaction([store_name], tx_readwrite).objectStore(store_name).delete(cacheName);

		request.onsuccess = function(e) {
		    deferred.resolve();
		};

		request.onerror = function(e){
			console.log('Error removing object from cache');
			cache_enabled = false;
			console.log(e);
			deferred.resolve();
		};

	} else deferred.resolve();

	return deferred.promise();

}

function setCache(cacheName,value) {

	var deferred = new $.Deferred();

	if (cache_enabled){

		try {

			var request = db.transaction([store_name], tx_readwrite).objectStore(store_name).put(value,cacheName);

			request.onsuccess = function(e) {
			    deferred.resolve();
			};

			request.onerror = function(e){
				console.log('Error adding object to cache');
				cache_enabled = false;
				console.log(e);
				deferred.resolve();
			};

		} catch (e) {
			console.log('Error adding object to cache');
			cache_enabled = false;
			console.log(e);
			deferred.resolve();
		}

	} else deferred.resolve();

	return deferred.promise();

}
var numTabs = 0;
var oTabs = {};
var oLeagueChars = {};

var currentItems = null;
var postThrottle = null;

// some defaults...
var currentLeague = '';
var lastView = '#openRareList';
var aVisibleCols = [];


// set in parseItems
var oTypes = {};
var oRarity = {};
var oProps = {};
var oRequired = {};
var oMods = {};
var oCalc = {};




$(document).ready(function(){

	getVersion();

	postThrottle = new Throttle(35000,25);

	// initialise the local browser db, once going, start loading data...
	var dbOpenPromise = initCache()
		.done(function(db, event){
			// load list of chars from server (or cache)
			// callback will select last selected char if there is one in the cache
			loadPageData();

		})
	;



});

function loadPageData() {
	refreshData(function(){
		getCache('last-league')
			.done(function(charName) {
				$('#leagueSelector li a[title="' + charName + '"]').trigger('click');
			})
			.fail(function(){
				
				// load league with the most chars
				var league = '';
				var charCount = 0;
				for (var l in oLeagueChars) {
					if (oLeagueChars[l].length > charCount) {
						charCount = oLeagueChars[l].length;
						league = l;
					}
				}
				if (league !== '') $('#leagueSelector li a[title="' + league + '"]').trigger('click');

			})
		;
	});
}

$('#refresh').click(function () {

	// store charname before we reset list of chars
	var charName = currentLeague;
	var currentView = lastView;
	var aCols = aVisibleCols;

	// clear all stored data
	resetCache(function(){

		// reload characters from server
		refreshData(function(){

			// reset charName and make sure it still exists
			setCache('last-league',charName);
			setCache('last-view', currentView);
			setCache('inventoryCols',aCols);

			$('#leagueSelector li a[title="' + charName + '"]').trigger('click');


		});

	});


});

$('#applyPartialRefresh').click(function(){

	var deleteQueue = new PromiseGroup();

	$('#refreshChars input[type=checkbox]:checked, #refreshTabs input[type=checkbox]:checked').each(function(idx,item){
		deleteQueue.addPromise( removeFromCache( $(item).val() ) );
	});

	deleteQueue.completed(function(){
		loadPageData();
	})




});

$('#partRefresh').click(function () {

	$('#refreshSelection').modal('show');

});

function refreshData(callback) {

	$('#rareList').hide();
	$('div#crafting-content div.crafting-block').hide();
	$('ul.nav li,ul#craftingTabs li').removeClass('active');

	getCache('league-data')

		.done(function(oLeague) {

			oLeagueChars = oLeague;

			getCache('oTabs').done(function(oT){

				oTabs = oT;
				numTabs = oT.length;
				initPage();
				if(jQuery.isFunction(callback)) callback();

			});

		})

		.fail(function(){
		console.log("Cache failed...");
			$.blockUI({message: '<h3>Loading...</h3><h4 id="waitOnQueue"></h4>', baseZ: 10000});

			getChars()

				.done(function (charResp) {

					if (charResp === null || charResp.error !== undefined || charResp[0] === '<') {
						showCharError();
						$.unblockUI();
						return;
					}

					// setCache('chars',charResp);

					var oLeagues = {};

					var loadQueue = new PromiseGroup();

					var throttleQueue = new PromiseGroup();

					// we have to request each characters items to find out what league they are in
					$.each(charResp,function(idx,item){

						loadQueue.addPromise(
							getCharItems(item.name)
								.done(function(oData){
									if (oData.hasOwnProperty('character') && oData.character.hasOwnProperty('league')) {
										if (!oLeagues.hasOwnProperty(oData.character.league)) oLeagues[oData.character.league] = [];
										oLeagues[oData.character.league].push(item.name);
									}
								})
						);

					});

					// all items have been requested (ie not sitting in queue)
					throttleQueue.completed(function(){
						// when loading all chars is complete save to cache
						loadQueue.completed(function(){

							oLeagueChars = oLeagues;
							setCache('league-data', oLeagueChars);

							// look up how many tabs we have
							for(var league in oLeagues) {

								if(oLeagues.hasOwnProperty(league)) {

								// load first leagues first stash tab to get tab info
									getStashPage(league,0)
										.done(function(oStash){

											oTabs = oStash.tabs;
											numTabs = oTabs.length;

											$.unblockUI();
		$.unblockUI();
		$.blockUI({message: '<h3>Building item table...</h3><h4 id="waitOnQueue"></h4>', baseZ: 1000});
											initPage();

											if(jQuery.isFunction(callback)) callback();

										})
									;

									break;
								}
							}


						});

					});

				})

				// failed to load character info
				.fail(function () {
					showCharError();
					$.unblockUI();
				})
			;
		})
	;

}

function getChars() {

	var deferred = new $.Deferred();

	$.post(getEndpoint('get-characters'))
		.done(function(data) {
			if (data) {
				deferred.resolve(data);
			} else {
				deferred.reject();
			}

		})
		.fail(function(){
			deferred.reject();
		})
	;

	return deferred.promise();


}
/*
function getChars() {

	var deferred = new $.Deferred();

	$.get('http://www.pathofexile.com/')
		.done(function(data) {

			var regexp = new RegExp(/CHARACTERS_DATA=(\{.+?\});/g);
			var aMatch = regexp.exec(data);

			if (aMatch) {
				var cdata = JSON.parse(aMatch[1]);
				deferred.resolve(cdata);
			} else {
				deferred.reject();
			}

		})
		.fail(function(){
			deferred.reject();
		})
	;

	return deferred.promise();

}
*/

function initPage(){

	var oDD = $('#leagueSelector')
		.empty()
	;

	for (var league in oLeagueChars) {
		oDD.append('<li><a title="' + league + '">' + league + '</a></li>');
	}

	sortUL(oDD);

	oDD.find('a').click(function(){

		var oThis = $(this);
		var league = oThis.text();

		$('#err').empty();

		currentLeague = league;

		oThis
			.closest('.dropdown')
				.addClass('active')
				.find('a.dropdown-toggle')
					.html(league + ' League <b class="caret"></b>')
		;

		oThis.parent().siblings().removeClass('active');

		oThis.parent().addClass('active');

		$('#output').html('');
		$('#rareList').html('');

		if (league != '') {
			setCache('last-league',league);
			loadLeagueData(league, false);
		}

	});

}


function getVersion() {

	$.getJSON('manifest.json',function(manifest){
		$('#version').html("Version: " + manifest.version);
	});

}



function PromiseGroup() {

	var self = this;

	var aPromise = [];

	this.completed = function(fn) {
		$.when.apply($,aPromise).done(fn);
	};

	this.failed = function(fn) {
		$.when.apply($,aPromise).fail(fn);
	};

	this.addPromise = function(promise) {
		aPromise.push(promise);
	};


}


//constructor for a new throttle instance
function Throttle(delayDuration,approxRequestsAllowed) {

	var self = this;

	this.period = delayDuration;
	this.requestsAllowed = approxRequestsAllowed;

	this.delayQueue = [];
	this.currentRequest = null;
	this.completedRequests = 0;
	this.avTime = 0;
	this.countDown = null;
	this.ticks = 0;


	this.updateStatus = function(undefined) {

		var delay = 0;
		var delay_periods = 0;

		if (self.ticks > 0) {
			// period less one sec per tick. + one period for every x outstanding requests.
			delay = self.period - (1000 * self.ticks);
			delay_periods = Math.floor(self.delayQueue.length / self.requestsAllowed);
		} else {
			// requests processed since last theoretical delay + queue length div requests per delay
			delay_periods = Math.floor( ((self.completedRequests % self.requestsAllowed) + self.delayQueue.length) / self.requestsAllowed);
		}

		// console.log('req left: ' + self.delayQueue.length + ', delay: ' + delay + ', delay periods: ' + delay_periods);

		delay += delay_periods * self.period;

		var estRemaining = Math.round( ((self.avTime * self.delayQueue.length) + delay) / 1000) ;

		if (estRemaining > 0) {
			$('#waitOnQueue').html("Estimated time remaining: " + estRemaining + ' seconds');
		} else {
			$('#waitOnQueue').empty();
		}
	};

	this.runRequest = function() {

		clearInterval(self.countDown);
		self.ticks = 0;

		if (!self.currentRequest) {
		 	if (self.delayQueue.length) {

				self.currentRequest = self.delayQueue.shift();

				var request = self.currentRequest.action;
				var deferred = self.currentRequest.deferred;
				var startTime = new Date().getTime();

				request()

					.done(function(result){

						if ( result.hasOwnProperty('error') ) {

							if (result.error.message.indexOf('too frequently') > -1) {
								self.delayQueue.push(self.currentRequest);
								self.currentRequest = null;
								self.updateStatus(self.period);
								setTimeout(self.runRequest, self.period);
								self.countDown = setInterval(function(){
									self.ticks++;
									self.updateStatus();
								},1000);

							} else {
								console.log(typeof result.error.message);
								console.log('PoE website returned error:');
								console.log(result.error.message);
								deferred.reject();
								self.currentRequest = null;
								self.runRequest();
								self.updateStatus();
							}


						} else {

							var endTime = new Date().getTime();
							self.avTime = ((self.avTime * self.completedRequests) + (endTime - startTime)) / ++self.completedRequests;
							deferred.resolve(result);
							self.currentRequest = null;
							self.runRequest();
							self.updateStatus();

						}

					})

					.fail(function(){
						deferred.reject();
						self.currentRequest = null;
						self.runRequest();
						self.updateStatus();
					})
				;

			} else {
			// reset stats as there are no active requests
				this.completedRequests = 0;
				this.avTime = 0;
			}
		}
	}

	// queues future calls to delay until the specified timeout (in milliseconds) has passed.
	// used to prevent flooding GGG's servers with too many stash requests in a short time.
	this.queue = function(queued_action) {

		var deferred = $.Deferred();

		self.delayQueue.push({action: queued_action, deferred: deferred});

		if (!self.currentRequest) self.runRequest();

		return deferred.promise();

	};

	// self.updateStatus();

}



function showCharError() {
	$('#err').html('Error retrieving character data from <a href="http://pathofexile.com">' +
				   'Path of Exile</a>.<p>Please sign in and refresh this page.');
}


function resetView() {

	// clear existing crafting info
	$('ul#craftingTabs li').remove();
	$('div#crafting-content').empty();

	//clear existing inventory info
	$('#rareList').empty();

	oTypes = {};
	oRarity = {normal: '', magic: '', rare: '', unique: '', skillGem: '', currency: ''};
	oProps = {};
	oRequired = {};
	oMods = {};
	oCalc = {};

	// clear reset lists
	$('#refreshChars, #refreshTabs, #craftingIgnoreChars, #craftingIgnoreTabs').empty();

	$('#inventoryMinLevel').val('0');
	$('#inventoryMaxLevel').val('100');

	currentItems = null;

}

function loadLeagueData(league) {


	var aChecked = [];
	$('#refreshChars, #refreshTabs, #craftingIgnoreChars, #craftingIgnoreTabs, #craftingLocation').find('input[type=checkbox]:checked').each(function(idx,item){
		aChecked.push('#' + $(item).attr('id'));
	});

	resetView();

	var items = [];

	$.blockUI({message: '<h3>Loading...</h3><h4 id="waitOnQueue"></h4>', baseZ: 100});

	try {

		var aChars = oLeagueChars[league];

		var loadQueue = new PromiseGroup();

		for (var i=0; i< aChars.length; i++) {
			loadQueue.addPromise(
				getCharItems(aChars[i]).done(function(oChar){
					$.merge(items, responseToItems(oChar, {section: oChar.charName, page: null, index: 0}));
							$("div.blockMsg").html('<h3>Merging data...</h3><h4 id="waitOnQueue"></h4>');
				})
			);
			$('#refreshChars').append('<li><label class="checkbox"><input type="checkbox" name="refreshChars" id="char_' + aChars[i] + '" value="char-' + aChars[i] + '">' + aChars[i] + '</label></li>');
			$('#craftingIgnoreChars').append('<li><label class="checkbox"><input type="checkbox" id="ignoreChars_' + aChars[i] + '" name="ignoreChars" value="' + aChars[i] + '">' + aChars[i] + '</label></li>');
		}

		var merge_function = function(oData){
			$.merge(items, responseToItems(oData, {section: 'stash', page: oTabs[oData.tabIndex].n, index:oData.tabIndex }));
		};

		// get the first tab (and tab labels) first...
		getStashPage(league,0).done(function(oData){

			try {

				oTabs = oData.tabs;
				numTabs = oTabs.length;
				if (numTabs > 0){
					merge_function(oData);
				} else {
					$('#err').html('It appears there is no data available for the ' + league + ' league on the server.<br /> Please ' +
								'select refresh then full after you have logged in and placed something your stash. If the error persists, contact the author.');
				}

			} catch (e) {

				$.unblockUI();
				$('#err').html('An error occured while requesting data from pathofexile.com. Please ' +
								'select refresh then full to try again. If the error persists, contact the author.');
				console.log('Error while fetching from pathofexile.com - try clicking "Refresh Data"');
				errorDump(e);
			}

		}).done(function(){

			try {

				for (var i=0; i < numTabs; i++ ) {
					var thisID = 'stash-' + league + '-' + i;
					$('#refreshTabs').append('<li><label class="checkbox"><input type="checkbox" name="refreshTabs" id="refresh-' + thisID + '" value="' + thisID + '">Tab:' + oTabs[i].n + '</label></li>');
					$('#craftingIgnoreTabs').append('<li><label class="checkbox"><input type="checkbox" name="ignoreTabs" id="ignore-' + thisID + '" value="' + i + '">Tab:' + oTabs[i].n + '</label></li>');
				}

				// recheck anything that was checked before the load
				if (aChecked.length) $(aChecked.toString()).prop('checked',true);



				for (var i=1; i < numTabs; i++ ) {
					if (i<2)
					{
	
	$("div.blockMsg").html('<h3>Reading cache...</h3><h4 id="waitOnQueue"></h4>');
					}

					loadQueue.addPromise(
						getStashPage(league,i).done(merge_function)
							
							
					);
				//	console.log('Requesting #' + i +'/'+numTabs+' from cache ');
				}

				loadQueue.completed(function(){

	
					processItems(items)
						.done(function(){
								
							getCache('last-view')
								.done(function(selector){
									lastView = selector;
									$(selector).trigger('click');
								})
								.fail(function(){
									$(lastView).trigger('click');
								})
							;
						})
					;


					$.unblockUI();
				})

				loadQueue.failed(function(){
					$('#err').html('An error occured while requesting data from pathofexile.com. Please ' +
								   'select refresh then full to try again. If the error persists, contact the author.');
					console.log('Error while fetching from pathofexile.com - try clicking "Refresh Data"');
					$.unblockUI();
				})

			} catch (e) {

				$.unblockUI();
				$('#err').html('An error occured while requesting data from pathofexile.com. Please ' +
							   'select refresh then full to try again. If the error persists, contact the author.');
				console.log('Error while fetching from pathofexile.com - try clicking "Refresh Data"');
				errorDump(e);
			}

		})


	} catch (e) {

		$.unblockUI();

		$('#err').html('An error occured while requesting data from pathofexile.com. Please ' +
					   'click refresh data to try again. If the error persists, contact the author.');
		console.log('Error while fetching from pathofexile.com - try clicking "Refresh Data"');

		errorDump(e);

	}



}


function responseToItems(response, location) {
	var items = []
	$.map(response.items, function (v) {

		// get the correct location for things outside stash
		var loc = location.page;

		if (location.section !== 'stash') {
			loc = v.inventoryId === 'MainInventory' ? 'Inventory' : 'Equipped';
		}

		// add this item
		items.push(parseItem(v, {section: location.section, page: loc, tabIndex: location.index}));

		loc += '*';

		// get any socketed items and add them
		if (v.hasOwnProperty('socketedItems') && v.socketedItems.length) {
			for (var i = 0; i < v.socketedItems.length; i++ ) {
				items.push(parseItem(v.socketedItems[i], {section: location.section, page: loc, tabIndex: location.index}));
			}
		}
	})
	return items;
}


function getEndpoint(method) {
		$("div.blockMsg").html('<h3>Accesing pathofexile.com...</h3><h4 id="waitOnQueue"></h4>');
	//	console.log('Accesing pathofexile.com');
	return "http://www.pathofexile.com/character-window/" + method;
}



function getCharItems(charName) {


	var deferred = $.Deferred();

	// first attempt to load from cache
	getCache('char-' + charName)
		//cache hit
		.done(function(oData){
			deferred.resolve(oData);
		})

		// cache miss
		.fail(function(){

			var thisChar = charName;

			postThrottle.queue( function() { return $.post(getEndpoint('get-items'), {character: thisChar}) } )
				.done(function(oData){
					// add char data to cache
					oData.charName = thisChar;
					setCache('char-' + thisChar , oData);
					deferred.resolve(oData);
				})
				.fail(function(){
					deferred.reject();
					return;
				})
			;


		})
	;


	return deferred.promise();
}


// returns a promse, which will return the stash page once loaded
function getStashPage(league,index) {

	var deferred = $.Deferred();

	// first attempt to load from cache
	getCache('stash-' + league + '-' + index)
		//cache hit
		.done(function(oData){
			deferred.resolve(oData);
					//console.log('Got stash page #' + (index+1) + ' cache');
		})

		// cache miss
		.fail(function(){
			console.log('failed to get cache');
			postThrottle.queue(function() { return $.post(getEndpoint('get-stash-items'), {league: league, tabIndex: index, tabs: index === 0 ? 1 : 0}) })

					.done(function (stashResp) {

						if(stashResp.error != undefined) {
							// early exit if web server returns the "you've requested too frequently" error
							deferred.reject();
							return;
						}

						// if the user hasn't put anything in their tabs/made a char/looted something this seems to return false. bleh.
						if (stashResp === false) {
							stashResp = {numTabs: 0, items: [], tabs:[]};
						}

						if (index === 0) {
			    			setCache('oTabs',stashResp.tabs);
						}

						stashResp.tabIndex = index;
						setCache('stash-' + league + '-' + index,stashResp);
						deferred.resolve(stashResp);
					})

					.fail(function(){
						deferred.reject();
						return;
					})
				;


		})
	;

	return deferred.promise();

}




function parseError(item,message) {
	console.log('<--- error begins...');
	console.log(item);
	console.log(message);
	console.log('error ends --->');
}






function parseItem(rawItem, loc) {


	try{

		var item = {
			location: loc,
			rarity: '',
			quality: 0,
			name: $.trim(rawItem.name + ' ' + rawItem.typeLine),
			identified: rawItem.identified,
			properties: {},
			explicitMods: {},
			implicitMods: {},
			combinedMods: {},
			requirements: {},
			sockets: {},
			calculated: {Quantity: 1},
			parentCategory: '',
			rawItem: rawItem

		};

		/*
		// item rarity
		if (rawItem.hasOwnProperty('normal') && rawItem.normal) item.rarity = 'normal';
		else if (rawItem.hasOwnProperty('magic') && rawItem.magic) item.rarity = 'magic';
		else if (rawItem.hasOwnProperty('rare') && rawItem.rare) item.rarity = 'rare';
		else if (rawItem.hasOwnProperty('unique') && rawItem.unique) item.rarity = 'unique';
		else if (rawItem.hasOwnProperty('gem') && rawItem.gem) item.rarity = 'skillGem';
		else if (rawItem.hasOwnProperty('currency') && rawItem.currency) {
			item.rarity = 'currency';
			var aMatch = item.name.match(/^\s*(\d+)x\s+(.*)$/);
			if (aMatch) {
				item.calculated.Quantity = aMatch[1];
				item.name = aMatch[2] + ' x' + aMatch[1];
				item.baseType = aMatch[2];
			} else {
				item.baseType = item.name;
			}
		}
		//if (item.rarity == '') parseError(item,'unknown item rarity');
		*/

		// item rarity
		switch(rawItem.frameType) {
			case 0: item.rarity = 'normal'; break;
			case 1: item.rarity = 'magic'; break;
			case 2: item.rarity = 'rare'; break;
			case 3: item.rarity = 'unique'; break;
			case 4:
				item.rarity = 'skillGem';
				break;
			case 5:
				item.rarity = 'currency';
				item.baseType = item.name;
				item.calculated.Quantity = rawItem.properties[0].values[0]; //TODO: regex the actualy quantity
				break;
			case 6: item.rarity = 'quest'; break;
			default:
				parseError(item, 'unknown item rarity');
		}

		item.baseType = itemBaseType(item);

		// get the item category if it's not a skill gem
		if (item.rarity !== 'skillGem') {
			item.category = itemCategory(item.baseType);
			if (item.category === 'weapon1h' || item.category === 'weapon2h') {
				item.parentCategory = item.category;
				item.category = item.rawItem.properties[0].name.replace(/ /g,'');
			} else if ($.inArray(item.category, ['head', 'chest', 'hands', 'feet','shield']) !== -1) {
				item.parentCategory = 'armor';
			} else if ($.inArray(item.category, ['amulet', 'belt', 'ring', 'quiver']) !== -1) {
				item.parentCategory = 'accessory';
			} else {
				item.parentCategory = 'misc'
			}
			if(item.category === null)  parseError(item,'unknown item category');
		} else {
			item.category = 'skillGem';
		}



		// get properties/mods/requirements into usable format
		if (rawItem.hasOwnProperty('requirements')) item.requirements = nameValueArrayToObj(rawItem.requirements,oRequired);

		// flasks and skillgems have some odd properties etc we don't want in the mix
		if (item.category !== 'skillGem' && item.rarity !== 'currency' && item.category != 'flask') {

			if (rawItem.hasOwnProperty('properties')) item.properties = nameValueArrayToObj(rawItem.properties,oProps);
			if (rawItem.hasOwnProperty('explicitMods')) item.explicitMods = processMods(rawItem.explicitMods,oMods);
			if (rawItem.hasOwnProperty('implicitMods')) item.implicitMods = processMods(rawItem.implicitMods,oMods);

			// combine explicit and implicit mods
			item.combinedMods = combineMods(item.explicitMods,item.implicitMods);

		}

		item.properties['Base Type'] = item.baseType;

		oProps['Base Type'] = '';
		oProps['Category'] = '';

		// get quality (gems and flasks need to be checked for this as props weren't parsed...)
		item.quality = itemQuality(item);

		if (item.properties.hasOwnProperty('Quality')) {
			item.properties['Quality'] = item.quality.toString() +'%';
		}

		item.itemRealType = item.baseType;

		var tmpCat = '';

		if (item.rarity == 'currency') {
			tmpCat = "Currency";
		} else if (item.category) {
			tmpCat =  item.category.charAt(0).toUpperCase() + item.category.slice(1);
		}

		item.properties['Category'] = tmpCat;

		if (!oTypes.hasOwnProperty(tmpCat)) oTypes[tmpCat] = {};
		if (!oTypes[tmpCat].hasOwnProperty(item.itemRealType)) oTypes[tmpCat][item.itemRealType] = '';

		item.rareName = itemRareName(item);

		item.sockets = itemSockets(rawItem);

		// calculated properties
		item.calculated['Average Lightning Damage'] = getAverageDamageOfType(item,'Lightning Damage');
		item.calculated['Average Cold Damage'] = getAverageDamageOfType(item,'Cold Damage');
		item.calculated['Average Fire Damage'] = getAverageDamageOfType(item,'Fire Damage');
		item.calculated['Average Chaos Damage'] = getAverageDamageOfType(item,'Chaos Damage');
		item.calculated['Average Physical Damage'] = getAverageDamageOfType(item,'Physical Damage');
		item.calculated['Average Damage'] = averageDamage(item);
		item.calculated['Max Linked Sockets'] = item.sockets.maxConnected;
		item.calculated['Sockets'] = item.sockets.numSockets;

		/*
		item.linkedSockets = getSocketLinkage(itemDiv);
		item.socketCount = item.sockets == null ? 0 : item.sockets.numSockets;
		*/

		// if the cacl'd properties cols aren't yet set, add them all
		if (!oCalc.hasOwnProperty('Average Damage')) {
			for (var key in item.calculated) {
				oCalc[key] = '';
			}
		}

	} catch(e) {

		console.log('Error parsing item from stash');
		console.log('Raw Item Data:');
		console.log(rawItem);
		console.log('Processed Item');
		console.log(item);

		errorDump(e);

		$('#err').html('An error occured while parsing an item in the stash. Please ' +
						'click refresh to try again. If the error persists, contact the author.');

	}

//	item.prefixes = itemPrefixes(item);
//	item.suffixes = itemSuffixes(item);
	return item;
}

function nameValueArrayToObj(aPairs, oKeys){
	var max  = aPairs.length;
	var oRet = {};
	for (var i = 0; i < max; i++){

		var key = aPairs[i].name;

		var keylen = aPairs[i].values.length;

		// some properties dont have a value
		if (keylen === 0) {

			oRet[key] = '';

		} else {

			var val = '';

			if (key == "Elemental Damage") {

				var sItem = "";
				var oThis = aPairs[i];

				for (var j = 0; j < keylen; j++) {

					// add the value of the damage
					sItem += oThis.values[j][0];

					// add the type of the elemental damage
					switch (oThis.values[j][1]) {
						case 4: sItem += ' (fire)'; break;
						case 5: sItem += ' (cold)'; break;
						case 6: sItem += ' (lightning)'; break;
						default: sItem += ''; break;
					}

					// skip the last comma
					if (j < keylen - 1) sItem += ", ";
				}

				val = sItem;

			} else {

				val = aPairs[i].values[0][0];
				if (val[0] === '<') val = $(val).text();
			}


			oRet[key] = val;
			if (!oKeys.hasOwnProperty(key)) oKeys[key] = '';

		}

	}
	return oRet;
}


function itemCategory(baseType) {
	if (baseType in ITEM_TYPE_DATA) { return ITEM_TYPE_DATA[baseType]; }
	if (baseType in CURRENCY_DATA) { return CURRENCY_DATA[baseType]; }

	// got changed in 0.9.12
	//if (baseType.match(/\(Level \d+\)/i)) { return 'skillGem'; }

	if (baseType.match(/\b(?:flask|vial)\b/i)) { return 'flask'; }
	if (baseType.match(/\bquiver\b/i)) { return 'quiver'; }
	return null;
}


var oTop = {};
var oLeft = {};

function getSocketLinkage(itemDiv) {

	var aSockets = $(itemDiv).find('div.sockets img[src$="Socket_Link_Horizontal.png"], div.sockets img[src$="Socket_Link_Vertical.png"]');

	if (aSockets.length == 0) return 0;
	if (aSockets.length == 1) return 2;

	var nodes = {};

	var setMaxLink = function(num) {
		for (var i = 1; i <= num; i++) {
			nodes[i] = [i];
		}
	}

	var addLink = function(nodeSource,nodeTarget) {

		//console.log('joining ' + nodeSource + ' to ' + nodeTarget );

		var aMerged = union_arrays(nodes[nodeSource],nodes[nodeTarget]);

		for (var i= 0; i < aMerged.length; i++) {
			nodes[aMerged[i]] = aMerged;
		}

	}

	setMaxLink(6);

	aSockets.each(function(index, item){

		item = $(item)

		var oLink = item.parent();
		var coords = oLink.attr('style').replace(/^.*top:(\d+).*left:(\d+).*$/,'($1,$2)')

		switch(coords) {

			case('(15,34)'):
				addLink(1,2);
				break;
			case('(62,34)'):
				addLink(3,4);
				break;
			case('(110,34)'):
				addLink(5,6);
				break;
			case('(34,15)'):
				addLink(1,3);
				break;
			case('(34,62)'):
				addLink(2,4);
				break;
			case('(82,15)'):
				addLink(3,5);
				break;
			case('(82,62)'):
				addLink(4,6);
				break;

			default:
				console.log('invalid coordinates for link: ' + coords);

		}

	});

	var maxlength = 0;

	for (var idx in nodes) {
		if (nodes[idx].length > maxlength) maxlength = nodes[idx].length;
	}

	return maxlength;

}


function union_arrays (x, y) {
  var obj = {};
  for (var i = x.length-1; i >= 0; -- i) obj[x[i]] = x[i];
  for (var i = y.length-1; i >= 0; -- i) obj[y[i]] = y[i];

  var res = []
  for (var k in obj) {
    res.push(obj[k]);
  }
  return res;
}


function averageDamage(item) {

	var dps = 0;

	var aTemp, aTemp2 = [];

	// if this is a weap, work it out as dps?
	if (item.parentCategory === 'weapon1h' || item.parentCategory === 'weapon2h') {

		// physical
		aTemp = item.properties['Physical Damage'].split('-');

		dps += ( parseInt(aTemp[0],10) + parseInt(aTemp[1],10) ) / 2;
		if (item.properties.hasOwnProperty('Elemental Damage')) {

			aTemp = item.properties['Elemental Damage'].split(', ');

			aTemp2 = $.map(aTemp,function(range){
				dps += calcAvRange(range);
			});

		}

		// for weaps multiply av dam by dps
		dps = Math.round(dps * parseFloat(item.properties['Attacks per Second']) * 10) / 10;

	} else {
		// not a weap, add up any elemental bonuses
		dps += item.calculated['Average Lightning Damage'];
		dps += item.calculated['Average Cold Damage'];
		dps += item.calculated['Average Fire Damage'];
		dps += item.calculated['Average Chaos Damage'];
		dps += item.calculated['Average Physical Damage'];
	}

	return dps;

}

function getAverageDamageOfType(item,mod) {
	if (item.properties.hasOwnProperty(mod)) return calcAvRange(item.properties[mod]);
	return item.combinedMods.hasOwnProperty(mod) ? calcAvRange(item.combinedMods[mod]) : 0;
}

function calcAvRange(range) {
	if (range.indexOf('-') > 0) var aTemp2 = range.split('-');
	else var aTemp2 = range.split(' to ');
	return ( parseInt(aTemp2[0]) + parseInt(aTemp2[1]) ) / 2;
}

// possibly need to combine an implicit + explicit mod.
function getPropertyOrModsInt(item,prop) {
	if (item.properties.hasOwnProperty(prop)) return item.properties[prop];

	var amt = 0;

	if (item.implicitMods.hasOwnProperty(prop)) amt += parseInt(item.implicitMods[prop]);
	if (item.explicitMods.hasOwnProperty(prop)) amt += parseInt(item.explicitMods[prop]);

	return amt;
}

function combineMods(explicitMods,implicitMods){

	var oCombined = {};
	for (var key in explicitMods) {
		oCombined[key] = explicitMods[key];
	}
	for (var key in implicitMods) {
		if (oCombined.hasOwnProperty(key)) {

			// can be int, % or range (x-y)
			var a = oCombined[key];
			var b = implicitMods[key];

			if (a.indexOf('-') > 0){
				// range
				a = a.split('-');
				b = b.split('-');
				oCombined[key] = (parseInt(a[0]) + parseInt(b[0])) + '-' + (parseInt(a[1]) + parseInt(b[1]));
			} else if (a.indexOf('%') > 0) {
				// percents
				a = parseInt(a.replace('%',''));
				b = parseInt(b.replace('%',''));
				oCombined[key] = a + b + '%';
			} else {
				oCombined[key] = parseInt(a) + parseInt(b);
			}

		} else {
			oCombined[key] = implicitMods[key];
		}
	}

	// add "elemental resistance" onto their respective elements
	if (oCombined.hasOwnProperty('% Elemental Resistances')){
		var allEleRes = parseInt(oCombined['% Elemental Resistances'],10);
		oCombined['% Lightning Resistance'] = parseInt(oCombined['% Lightning Resistance'] || 0,10) + allEleRes + '%';
		oCombined['% Cold Resistance'] = parseInt(oCombined['% Cold Resistance'] || 0,10) + allEleRes + '%';
		oCombined['% Fire Resistance'] = parseInt(oCombined['% Fire Resistance'] || 0,10) + allEleRes + '%';
	}

	return oCombined;

}

function processMods(aExplicit,oKeys) {

	var oExplicit = {};

	var bonusRegexp =   /^\+?(\d+) [^A-Z]*(.*)$/;
	var percentRegexp = /^\+?(\d+%) [^A-Z]*(.*)$/;
	var damRegexp = /^Adds (\d+-\d+) (.* Damage)$/i;


	var aMatch = [];

	for(var i = 0; i < aExplicit.length; i++) {

		var thisMod = aExplicit[i];
		var key = '';

		aMatch = bonusRegexp.exec(thisMod);
		if (aMatch !== null) {
			key = '+ ' + aMatch[2];
		} else {
			aMatch = percentRegexp.exec(thisMod);
			if (aMatch !== null) {
				key = '% ' + aMatch[2];

			} else {
				aMatch = damRegexp.exec(thisMod);
				if (aMatch !== null) key = aMatch[2];
			}
		}

		if (aMatch !== null) {
			oExplicit[key] = aMatch[1];
			if (!oKeys.hasOwnProperty(key)) oKeys[key] = '';
		}

	}

	return oExplicit;

}

function itemLevel(item) {

	if (item.requirements.hasOwnProperty('Required Level')) return parseInt(item.requirements['Required Level'],10);
	if (item.properties.hasOwnProperty('Required Level')) return parseInt(item.properties['Required Level'],10);

	if (item.category == 'skillGem') console.log(item);

	return 1;
}

function itemRealType(item){

	if (item.properties.hasOwnProperty('Weapon Class') ) {
		return item.properties['Weapon Class'];
	}

	if (item.rarity == 'currency') return 'Currency';

	if (item.category !== null) return capitaliseFirstLetter(item.category);

	return '';

}


function itemBaseType(item) {
	if(item.rarity == 'currency') {
		return item.baseType;
	}

	if (!item.identified || item.rarity == 'normal') {
		// get rid off the "Superior"
		return item.name.replace(/^Superior /, '');
	}

	if (item.rarity == 'rare') {
		// some rares have an additional space that needs to be trimmed
		return item.name.split(' ').slice(2).join(' ').replace(/^ /, '');
	}

	if (item.rarity == 'magic') {

		// get rid of any suffix mods.
		var baseType = item.name.replace(/\s+of.*$/,'');
		var aWords = baseType.split(' ');

		// we need to check each combination of the words to see if it's in item data.
		// max length of basetype is 3 words (that i've found so far...)
		//i.e
		// Ample Sacred Hybrid Flask. check Sacred Hybrid Flask then Hybrid Flask then Flask
		for (var i = Math.max(0, aWords.length-3); i<aWords.length; i++ ) {
			var baseName = aWords.slice(i).join(' ');
			if (baseName in ITEM_TYPE_DATA) return baseName;
		}

		// at this point we SHOULD have a potion.
		// but we might also have an unrecognised prefix
		// or an unrecognised item basetype

		// we can reliably recognise a potion

		// njs: not sure why these aren't in item data?
		if(baseType.match(/\b(?:flask|vial)\b/i)) {
			// though if it's both a potion AND an unrecognised prefix we've got a problem.
			return baseType;
		}

		// we must have an unrecognised  item type
		console.log("Unrecognised item type: " + baseType);
		console.log(item);

		return baseType;

	}

	// TODO(jaguilar): handle uniques.
	if (item.rarity == 'unique') {
		if (item.rawItem.typeLine.length > 0) return item.rawItem.typeLine;
	}

	return item.name;
}



function itemRareName(item) {
	var splitName;
	var combinedName;

	if (item.rarity != 'rare' || !item.identified) { return null; }

	splitName = item.name.split(' ');
	combinedName = splitName[0] + ' ' + splitName[1];

	// some rares have an additional space and wont give an alch
	// if sold to a vendor with a matching rare
	if (splitName[2] == '') {
		combinedName += ' ';
	}

	return combinedName;
}

function itemSockets(rawItem) {

	var numSockets = 0;
	var tricolor = false;  // Any connected seqs with all three colors?
	var maxConnected = 0;  // Max # in a connected seq.


	if (rawItem.hasOwnProperty('sockets')) {

		var aSockets = rawItem.sockets;
		var oSockets = {};

		// convert array into a struct of socket groups + number of each socket type
		$.each(aSockets,function(idx,item){
			if (!oSockets.hasOwnProperty(item.group)) oSockets[item.group] = {};
			if (!oSockets[item.group].hasOwnProperty(item.attr)){
				oSockets[item.group][item.attr] = 1;
			} else {
				++oSockets[item.group][item.attr];
			}
		});

		for (var idx in oSockets){
			var oGroup = oSockets[idx];

			var connectsInGroup = 0;
			var types = 0;
			for (var type in oGroup) {
				connectsInGroup += oGroup[type];
				types++;
			}
			numSockets += connectsInGroup;
			if (connectsInGroup > maxConnected) maxConnected = connectsInGroup;
			if (types == 3) tricolor = true;

			if (oGroup.hasOwnProperty('D') && oGroup.hasOwnProperty('S') && oGroup.hasOwnProperty('I')) tricolor = true;

		}

	}

	return {
		tricolor: tricolor,
		maxConnected: maxConnected,
		numSockets: numSockets
	};
}

function itemQuality(item) {


	if (item.category === 'skillGem' || item.category === 'flask') {

		if (item.rawItem.hasOwnProperty('properties')) {
			for(var i = 0; i< item.rawItem.properties.length;i++) {
				var oProp = item.rawItem.properties[i];
				if (oProp.name === 'Quality') {
					item.properties.Quality = oProp.values[0];
					return parseInt(oProp.values[0],10);
				}
			}
		}

	} else {

		if (item.properties.hasOwnProperty('Quality')) {
			return parseInt(item.properties.Quality,10);
		}

	}

	return 0;
}

function itemByName(items, name) {
	return $(items.filter(function(i){return $(':contains(' + name + ')', $(i.html)).length > 0})[0].html)
}

var Match = Class.extend({
	init: function() {
	},

	// Consider an item for matching. If you return true, that means that this matcher
	// now owns this item for the remainder of its lifetime.
	take: function (i) {
		return false;
	},

	// Returns a list of matches, which are objects with the following properties:
	// - complete: a number in [0, 1] that represents the completeness of this match.
	//     1 is complete.
	//     *Bodged in additional meaning to this value. More than 1 is interpreted as meaning the ingredients can generate multiples of the output.
	//     e.g. 18x chromaticOrb + 18x fusingOrb = 18x jewelersOrb. The 'complete' value should be 18.
	//     It's basically a way of preventing the recipe hits from flooding the output with trivial repeat data, while still giving the user the data they need.
	//
	// - items: owned items that we matched on
	// - missing: a list of strings to display to the user carrying items that
	//            were not found in the list.
	getMatches: function () {
		return [];
	}
});


var RarenameMatch = Match.extend({
	init: function(count,bQuality) {
		this.count = count;
		this.bQuality = bQuality;
		this.matches = {};
	},

	take: function(i) {
		if (i.rarity !== 'rare' || !i.identified) {
			return;
		}
		if (this.bQuality && i.quality !== 20){
			return;
		}
		if (!this.matches.hasOwnProperty(i.rareName)){
			this.matches[i.rareName] = [];
		}
		this.matches[i.rareName].push(i);
	},

	getMatches: function() {
		var th = this;
		return $.map(this.matches, function (v, k) {
			return {
					complete: v.length * 1.0 / th.count,
					items:v,
					missing: [sprintf('%d ' + (this.bQuality ? '20% quality' : '') + ' rare(s) with this rarename:', th.count - v.length), k]
				};
		});
	}
});


var BaseNameAndTypeMatch = Match.extend({
	init: function(type,count) {
		this.count = count;
		this.type = type;
		this.matches = {}
	},

	take: function(i) {
		if (i.category != this.type) return;
		var matchArray = this.matches[i.baseType];
		if (matchArray == null) {
			matchArray = this.matches[i.baseType] = []
		}
		matchArray.push(i);
	},

	getMatches: function() {
		var th = this;
		return $.map(this.matches, function (v, k) {
			return {complete: v.length * 1.0 / th.count,
				    items:v,
					missing: [sprintf('%d %s of type:', th.count - v.length, th.type), k]}
		});
	}
});

var CurrencyMatch = Match.extend({
	// currencyRequirements; an array of objects with name:<shortCurrencyName>, [quantity:numberNeededForMatch] (optional)
	init: function(currencyRequirements) {
		this.currencyRequirements = currencyRequirements;
		this.currencyRequirements.forEach(function(currency) {
			currency.count = 0;
			if(!currency.quantity) {
				currency.quantity = 1;
			}
		});
		this.owned = [];
	},

	take: function (i) {
		if(i.rarity!='currency') return false; // not currency
		if(!i.baseType in CURRENCY_DATA) return false; // not recognised type of currency

		var take = false;
		this.currencyRequirements.forEach(function(currency){
			if(currency.name==CURRENCY_DATA[i.baseType]) {
				currency.count+=i.quantity;
				this.owned.push(i);
				take = true;
			}
		}, this);
		return take;
	},

	getMatches: function () {
		var lowestMatchCount = null;

		this.currencyRequirements.forEach(function(currency) {
			var matchCount = currency.count/currency.quantity;
			if(lowestMatchCount==null || matchCount<lowestMatchCount) {
				lowestMatchCount = matchCount;
			}
		});

		var out;

		if(lowestMatchCount<1) {

			var missingStuff = "";

			this.currencyRequirements.forEach(function(currency) {
				if(currency.count<currency.quantity) {
					missingStuff+=sprintf("%dx %s<br>",currency.quantity-currency.count,currency.name);
				}
			});


			out = [{complete:lowestMatchCount, items:this.owned, missing:missingStuff}];
		}
		else {
			out = [{complete:lowestMatchCount, items:this.owned}];
		}

		return out;
	}
});

var combine = function(a, min, max, targetqual, itemBin) {
    var fn = function(n, src, got, all) {
        if (n === 0) {
			var quality = 0;
			for (var count = 0; count < got.length; count++) {
				quality += got[count].quality;
			}
            if (got.length > 0 && quality == targetqual) {

				for (var g=0; g < got.length; g++) {
					if (itemBin.indexOf(got[g]) != -1) {
						return;
					}
				}
				all.push( {itemset: got, quality: quality} );
				for (var g=0; g < got.length; g++) {
					itemBin.push(got[g]);
				}
            }
            return;
        }
        for (var j = 0; j < src.length; j++) {
			fn(n - 1, src.slice(j + 1), got.concat([src[j]]), all);
        }
        return;
    };
    var all = [];
    for (var i = min; i <= max; i++) {
        fn(i, a, [], all);
    }
    return all;
};


var QualityMatch = Match.extend({
	// acceptableType: one of armor, flask, skillGem, or weapon.
	init: function(acceptableType) {
		this.acceptableType = acceptableType;
		this.maxItems = 75;
		this.maxSetQuality = 44;
		this.itemList = []; // [{item, quality}]
		this.setList = []; // [{itemset: [{item, quality}], quality}]
		this.usedItems = [];
		this.totalQuality = 0;
		this.matches = [];
	},

	consider: function (i) {
		if (i.category === undefined) {return false;}
		if (i.quality === 0) {return false;}
		return (this.acceptableType === 'weapon' && $.inArray(i.parentCategory, ['weapon1h', 'weapon2h']) !== -1) ||
			(this.acceptableType === 'armor' && i.parentCategory === 'armor') ||
			(this.acceptableType === i.category);  // skillGem or flask
	},

	take: function (i) {
		if (!this.consider(i)) { return; }
		// only normal quality 20% is acceptable it seems...
		if (i.quality === 20 && i.rarity === 'normal') {
			this.matches.push({complete: 1, items: [i]});
		}
		else if (i.rarity == 'unique') {
			return;
		}
		else if (this.itemList.length < this.maxItems) {
			this.itemList.push( {item: i, quality: i.quality} );
			this.totalQuality += i.quality;
			}
	},

	getMatches: function () {

		if (this.itemList.length === 0) {
			return [];
		}

		if (this.itemList.length < 30) {
			maxSetSize = 7;
		} else if (this.itemList.length >= 30 && this.itemList.length < 40) {
			maxSetSize = 6;
		} else if (this.itemList.length >= 40) {
			maxSetSize = 5;
		}

		var remainingItems = this.itemList.slice(0);
		for (var z=40; z <= this.maxSetQuality; z++) {
			this.setList = this.setList.concat(combine(remainingItems, 2, maxSetSize, z, this.usedItems));
			remainingItems = [];
			for (var t=0; t < this.itemList.length; t++) {
				if (this.usedItems.indexOf(this.itemList[t]) == -1) {
					remainingItems.push(this.itemList[t]);
				}
			}
			if (remainingItems.length === 0)
				{ break; }
		}
		if (this.setList.length === 0) {
			return [];
		}

		var setsQuality = 0;
		for (var t=0; t < this.setList.length; t++) {
			setsQuality += this.setList[t].quality;
		}
		// console.log("this.acceptabletype: " + this.acceptableType + " itemList.length: " + this.itemList.length + " setList.length: " + this.setList.length + " usedItems.length: " + this.usedItems.length + " Quality: " + setsQuality + "/" + this.totalQuality);

		// List unused items
		// console.log(remainingItems);


		for (var t=0; t < this.setList.length;t++) {

			var myItems = [];
			for (var u=0; u < this.setList[t].itemset.length; u++) {
				myItems = myItems.concat(this.setList[t].itemset[u].item);
			}
			this.matches.push({complete: this.setList[t].quality / 100, items: myItems});
		}

		return this.matches;
	}
});

var PredicateMatcher = Match.extend({
	init: function(pred) {
		this.matches = [];
		this.pred = pred;
	},

	take: function(i) {
		if (this.pred(i)) {
			this.matches.push(i);
		}
	},

	getMatches: function() {
		return $.map(this.matches, function (v, _) {
			return {complete: 1, items:[v]};
		});
	}
});

function TricolorMatch() {
	return new PredicateMatcher(function (i) { return i.sockets && i.sockets.tricolor; });
}

function SocketMatch(reqcount, linked) {
	return new PredicateMatcher(
		function (i) {
			return i.sockets && ((linked ? i.sockets.maxConnected : i.sockets.numSockets) >= reqcount);
		});
}
function RareModMatch(modcount) {
	return new PredicateMatcher(
		function (i) { return i.rarity == 'rare' && i.rawItem.hasOwnProperty('explicitMods') && i.rawItem.explicitMods.length > modcount; });
}

var BaseTypeMatch = Match.extend({
	// The most important rarity should be first, then the second, and so on.
	// We use this to score match completion, with each index getting descending amounts
	// credit.
	init: function(rarities, maxQuality, allowedToBePartlyIdentified) {
		this.scores = {unique:4, rare:2, magic:1, normal: 1};
		this.rarities = rarities;
		this.maxQuality = maxQuality;
		this.allowedToBePartlyIdentified = allowedToBePartlyIdentified;
		this.matches = {};
		this.completeScore = this.scoreRarities(rarities);
	},

	// Score an array of rarities.
	scoreRarities: function(r) {
		var s = 0;
		for (var i = 0; i < r.length; ++i) {
			s += this.scores[r[i]];
		}
		return s;
	},

	take: function(i) {
		// Don't keep anything without a
		if (i.baseType === null || $.inArray(i.rarity, this.rarities) === -1 || (i.quality < 20 && this.maxQuality)) { return; }

		if(!this.allowedToBePartlyIdentified && i.identified) { return false;}

		if (!this.matches.hasOwnProperty(i.baseType)) {
			this.matches[i.baseType] = {};
		}

		this.matches[i.baseType][i.rarity] = i;  // It's fine to replace what's already here.

	},

	credit: function(i) {
		if (i === 0) { return 0; }
		return i + this.credit(i-1);
	},

	getMatches: function() {
		var maxCredit = this.credit(this.rarities.length);
		var th = this;

		return $.map(this.matches, function (v, k) {
			var itemcredit = 0;
			var missing = $.map(th.rarities, function(rarity, idx) {
				if (!(rarity in v)) {
					return rarity;
				}
			});

			return {
				items: objToArray(v),
				missing: $.merge([sprintf('%s%s with rarities:', k, th.maxQuality ? ' with %20 quality' : '')], [missing.join(', ')]),
				complete: 1 - (1.0 * th.scoreRarities(missing) / th.completeScore)
			};
		});
	}

});

function objToArray(v) {

	var a = [];
	for (var k in v){
		if (v.hasOwnProperty(k)) a.push(v[k]);
	}

	return a;

}


function mapMax(maps) {
	var out = {};
	$.map(maps, function (aMap, _) {
		$.map(aMap, function(v, k) {
			if (!out[k]) {
				out[k] = 0;
			}
			out[k] = Math.max(v, out[k]);
		});
	});
	return out;
}

var BaseTypeAndRarityMatch = Match.extend({
	init: function(countNeeded){
		this.countNeeded = countNeeded;
		this.itemMap = {};
	},

	take: function(i) {
		if (i.baseType === undefined) {return false;}
		if (i.rarity != 'rare' && i.rarity != 'magic' && i.rarity != 'unique') { return false; }

		var combinedName = i.rarity + ' ' + i.baseType;
		var items = this.itemMap[combinedName];
		if (items === undefined) {
			this.itemMap[combinedName] = items = [];
		}
		items.push(i);
		return true;
	},
	getMatches: function() {

		var out = [];

		for(var combinedName in this.itemMap) {
			var itemArray = this.itemMap[combinedName];
			var isComplete = itemArray.length>=this.countNeeded;
			out.push({ complete : isComplete?1:(itemArray.length/this.countNeeded),
						items:itemArray.slice(0,5),
						missing: isComplete?null:[sprintf("%dx %s", this.countNeeded-itemArray.length, combinedName)]
			});

		}

		return out;
	}
});


var FullsetMatch = Match.extend({

	init: function(rarity, mustBeTopQuality, mustBeUnidentified) {
		this.rarity = rarity;
		this.mustBeTopQuality = mustBeTopQuality;
		this.mustBeUnidentified = mustBeUnidentified;
		this.matchedParts = {
			head: [],
			chest: [],
			hands: [],
			feet: [],
			belt: [],
			ring: [],
			amulet: [],
			weapon1h: [],
			weapon2h: [],
			shield: []
		};
		this.armorPart = count(['head', 'chest', 'hands', 'feet', 'belt', 'ring', 'ring', 'amulet']);
		this.weaponPart = [count(['weapon1h', 'shield']), count(['weapon2h']), count(['weapon1h', 'weapon1h'])];
	},

	hasCount: function(c) {
		var th = this;
		var has = all(c, function (v, k) {
			var res = th.matchedParts[k].length >= v;
			return res;
		});
		return has;
	},

	// Pulls items in a "recipe" (a map of strings to counts) from this.matchedParts into a second array.
	// This will be reported to the used.
	extractItems: function(recipe) {
		var th = this;
		return $.map(recipe, function (v, k) {
			var out = [];
			for (var countNeeded = v; countNeeded > 0; --countNeeded) {
				out.push(th.matchedParts[k].pop());
			}
			return out;
		});
	},

	// If the requirements are satisfied, returns a minimal satisfying set of requirements.
	// Otherwise, returns the maximal satisfying set.
	getMatchRequirements: function() {
		var th = this;
		var weaponReqs = any(this.weaponPart, function (v, _) { return th.hasCount(v); });
		if (weaponReqs) {
			return mapMax([this.armorPart, weaponReqs[0]]);
		} else {
			return mapMax($.merge([this.armorPart], this.weaponPart));
		}
	},

	getCompleteMatches: function() {
		var matches = [];
		while (true) {
			var matchRequirements = this.getMatchRequirements();
			if (this.hasCount(matchRequirements)) {
				matches.push({complete: 1, items: this.extractItems(matchRequirements)});
			} else {
				break;
			}
		}
		return matches;
	},

	getMatches: function() {
		var th = this;
		var matches = this.getCompleteMatches();

		// The last one is a partial match. This is pretty tricky to represent. What we're going to
		// do is return the values of matchedParts as the items. We'll figure out what parts aren't
		// complete by iterating over the min key values of this.combos against the length of each
		// array in items. Completeness will be the length of 1 - (missing parts / missing+available).
		var requirements = this.getMatchRequirements();
		var missing = $.map(this.matchedParts, function (v, k) {
			var out = [];
			for (var missingCount = requirements[k] - v.length; missingCount > 0; --missingCount) {
				out.push(k);
			}
			return out;
		});
		// Get a composition of items that represents a partial suit. The slice is to prevent taking
		// more than required (we only want one chest, etc. for the partial match).
		var partialItems = $.map(this.matchedParts,
								function (v, k) {
									if (requirements[k]) {
										return v.slice(0, requirements[k]);
									}
								});
		if (missing.length) {
			var firstMissingRow = sprintf('%s %sitems in slots:', this.rarity, this.topQuality ? '20% quality ' : '');
			missing = $.merge([firstMissingRow], missing);
		}
		matches.push({
			complete: 1 - ((missing.length * 1.0) / (missing.length + partialItems.length)),
			items: partialItems,
			missing: missing
		});
		return matches;
	},

	take: function(i) {
		if(this.mustBeUnidentified && i.identified) { return false; }
		if (this.rarity != i.rarity) { return false; }
		if (this.mustBeTopQuality && i.quality != 20) { return false; }
		var cat = (i.parentCategory === 'weapon1h' || i.parentCategory === 'weapon2h') ? i.parentCategory : i.category;
		if (cat in this.matchedParts) {
			this.matchedParts[cat].push(i);
		}
	}
});

function allMatches(available) {
	var results = {};

	var matchRules = $.map([
							{result: "Armorer's Scrap", matcher: new QualityMatch('armor'), display:0.39},
							{result: "Blacksmith's Whetstone", matcher: new QualityMatch('weapon'), display:0.39},

							{result: "Chaos Orb", matcher: new FullsetMatch('rare', false, false), display:0.3},
							{result: "2 Chaos Orbs", matcher: new FullsetMatch('rare', false, true), display:0.3},

							{result: "Regal Orb", matcher: new FullsetMatch('rare', true, false), display:0.3},
							{result: "2 Regal Orbs", matcher: new FullsetMatch('rare', true, true), display:0.3},

							{result: "Chromatic Orb", matcher: TricolorMatch()},
							{result: "Divine Orb", matcher: SocketMatch(6, true)},

							{result: "Gemcutter's Prism", matcher: new QualityMatch('skillGem'), display:0.3},

							{result: "Cartographer's Chisel", matcher: new QualityMatch('map'), display:0.3},

							{result: "Glassblower's Bauble", matcher: new QualityMatch('flask')},

							{result: "Jeweler's Orb", matcher: new CurrencyMatch([{name:'chromaticOrb'},{name:'fusingOrb'}])},

							{result: "7 Jeweler's Orbs", matcher: SocketMatch(6, false)},

							{result: "Orb of Chance", matcher: new RarenameMatch(2,false), display:0.51},
							{result: "Orb of Alchemy", matcher: new RarenameMatch(3,false), display:0.94},

							{result: "Orb of Alchemy", matcher: new RarenameMatch(2,true), display:0.51},
							{result: "Regal Orb", matcher: new RarenameMatch(3,true), display:0.6},


							{result: "Orb of Augmentation", matcher: new BaseTypeMatch(['rare', 'magic', 'normal'], false, true), display:0.51},
							{result: "2 Orbs of Augmentation", matcher: new BaseTypeMatch(['rare', 'magic', 'normal'], false, false), display:0.51},

							{result: "Orb of Alchemy", matcher: new BaseTypeMatch(['rare', 'magic', 'normal'], true, true), display:0.51},
							{result: "2 Orbs of Alchemy", matcher: new BaseTypeMatch(['rare', 'magic', 'normal'], true, false), display:0.51}, //This rule is unverified.

							{result: "Map one level higher", matcher: new BaseNameAndTypeMatch('map',3), display:0.51}, //This rule is unverified.

							{result: "Orb of Augmentation", matcher: RareModMatch(6)}, //This rule is flawed. It is impossible to reliably determine if a rare has 6 mods.

							{result: "5 Orbs of Chance", matcher: new BaseTypeMatch(['unique', 'rare', 'magic', 'normal'], false, true), display: 0.5},



							{result: "1 Divine, 2 Exalted and 5 Regal Orbs",  matcher: new CurrencyMatch([{name:'mirrorOfKalandra'}]), display:0.98},

							{result: "New unidentified item of same base type & rarity",  matcher: new BaseTypeAndRarityMatch(5), display:0.7}

							//TODO The rules that rely upon allowedToBePartlyIdentified are slightly bugged at the moment.
							// When set they'll accept all unidentified, which should be taken by the more valuable rule.
							//TODO add obvious recipes?


	], function (v, _) {
		// Defaults.
		if (v.display == null) { v.display = 0; }
		return v;
	});

	// iterate over the rules
	$.each(matchRules, function (_, rule) {

		var matcher = rule.matcher;

		// let the matcher take the items it's interested in.
		$.map(available, function (i) { matcher.take(i); });
		// filter out matches that fall below the display threshold.
		var matches = (matcher.getMatches().filter(function(m) { return m.complete > rule.display; }));

		// if this rule made any matches, then the matches need adding to the results
		if (matches.length) {
			if (results[rule.result] == null) {
				results[rule.result] = [];
			}
			results[rule.result] = $.merge(results[rule.result], matches);
		}
	});
	return results;
}

function locationFormat(i) {
	if (i.location.section == 'character') { return 'char'; }
	else { return sprintf('stash %s', i.location.page); }
}

function itemSpan(i) {
	return sprintf('%s&nbsp;&nbsp;&nbsp;&nbsp<span class="location">%s</span>', i.name, locationFormat(i));
}

var aInventory = [];
var craftItems = [];

$.tablesorter.defaults.theme = 'bootstrap';
$.tablesorter.defaults.headerTemplate = '{content} {icon}';

$.tablesorter.defaults.widgets = ['uitheme','stickyHeaders','zebra', 'filter'];
$.tablesorter.defaults.widgetOptions = {uitheme: 'bootstrap', stickyHeaders : 'tablesorter-stickyHeader', stickyOffset: '100'};

$.tablesorter.defaults.sortInitialOrder = 'desc';
$.tablesorter.defaults.sortInitialOrder = 'desc';

// after a resort on a table scroll to the top (as sticky header maybe hiding content)
$(document).on('sortEnd','table',function(e,t){
	$.scrollTo(t, {offset: {top: -60}});
})

$('#resetCols').click(function(){
	$('#inventoryCols input[type=checkbox]:checked').prop('checked',false);
	return false;
});
$('#showAllCols').click(function(){
	$('#inventoryCols input[type=checkbox]').prop('checked',true);
	return false;
});

// enable shift click for checkboxes

//craftingIgnoreTabs,craftingIgnoreChars,refreshTabs,refreshChars
var cbLastID = '';
var cbLastName = '';

$(document).on("click","li input[type=checkbox]",function(evt){

	var oThis = $(evt.target);

	var thisName = oThis.attr('name');
	var thisID = oThis.attr('id');

	if (thisName === cbLastName && $.trim(thisName !== '') && evt.shiftKey ) {
		var aCB = $('input[name="' + thisName + '"]');
		var oFirst = $('#' + cbLastID);
		aCB.slice($.inArray(oFirst[0],aCB), $.inArray($('#' + thisID)[0],aCB)+1).prop('checked',oFirst.prop('checked'));
	}

	cbLastID = thisID;
	cbLastName = thisName;

});

function setupInventoryRendering(items) {

	var deferred = new $.Deferred();

	var key = '';
	var id ='';

	// setup available properties
	var oPropUL = $('ul#viewProps').empty();
	for (key in oProps) {
		if (oProps.hasOwnProperty(key)){
			id = key.replace(/[^a-zA-Z]/g,'_');
			oPropUL.append('<li><label class="checkbox" for="prop_' + id + '"><input class="checkbox" type="checkbox" id="prop_' + id + '" name="viewProps" checked="checked" value="' + key + '" />' + key + '</label></li>');
		}
	}
	sortUL(oPropUL);


	// setup available mods
	var oModUL = $('ul#viewMods').empty();
	for (key in oMods) {
		if (oMods.hasOwnProperty(key)){
			id = key.replace(/[^a-zA-Z]/g,'_');
			oModUL.append('<li><label class="checkbox" for="mod_' + id + '"><input class="checkbox" type="checkbox" id="mod_' + id + '" name="viewMods"  checked="checked"  value="' + key + '" />' + key + '</label></li>');
		}
	}
	sortUL(oModUL);



	// setup available calculated cols
	var oCalcUL = $('ul#viewCalculated').empty();
	for (key in oCalc) {
		if (oCalc.hasOwnProperty(key)){
			id = key.replace(/[^a-zA-Z]/g,'_');
			oCalcUL.append('<li><label class="checkbox" for="calc_' + id + '"><input class="checkbox" type="checkbox" id="calc_' + id + '" name="viewCalc"  checked="checked"  value="' + key + '" />' + key + '</label></li>');
		}
	}
	sortUL(oCalcUL);


	// setup available requirements
	var oReqUL = $('ul#viewReqs').empty();
	for (key in oRequired) {
		if (oRequired.hasOwnProperty(key)) {
			id = key.replace(/[^a-zA-Z]/g,'_');
			oReqUL.append('<li><label class="checkbox" for="req_' + id + '"><input class="checkbox" type="checkbox" id="req_' + id + '" name="viewReq"  checked="checked"  value="' + key + '" />' + key + '</label></li>');
		}
	}
	sortUL(oReqUL);

	// setup available types
	var oTypeUL = $('ul#viewCategories').empty();
	for (key in oTypes) {
		if (oTypes.hasOwnProperty(key)) {
			var cbox = '<input type="checkbox" class="checkboxBoss" checked data-target="#view' + key + '"/>';
			var expandLink = '<a class="btn-small" href="#" data-toggle="collapse" data-target="#view' + key + '"><i class="icon-white icon-chevron-down"></i></a>';
			var list = $('<li><label class="checkbox">'+ cbox + key +'' + expandLink + '</label></li>')
				.appendTo(oTypeUL);
			var inner =  $('<ul id="view'+key+'" class="collapse" style="list-style: none;"/>').appendTo(list);

			for (var type in oTypes[key]) {
				if (oTypes[key].hasOwnProperty(type)) {
					id = type.replace(/[^a-zA-Z]/g,'_');
					inner.append('<li><label class="checkbox" ><input checked type="checkbox" value="' + type + '" name="viewType"/>' + type + '</label></li>');
				}
			}
		}
	}
	sortUL(oTypeUL);

	// setup available rarity
	var oRarityUL = $('ul#viewRarity').empty();
	for (key in oRarity) {
		if (oRarity.hasOwnProperty(key)) {
			id = key.replace(/[^a-zA-Z]/g,'_');
			oRarityUL.append('<li><label class="checkbox" for="rarity_' + id + '"><input class="checkbox" checked type="checkbox" id="rarity_' + id + '" name="viewRarity" value="' + key + '" />' + capitaliseFirstLetter(key) + '</label></li>');
		}
	}
	sortUL(oRarityUL);

	// add select all/none checkboxes to types and rarity
	$('input.toggleCheckboxes').click(function(){
		$('input[name=' + $(this).data('toggling') + ']').prop('checked',$(this).prop('checked'));
	});

	$('input.checkboxBoss').click(function() {
		$($(this).data('target')).find('input[type=checkbox]').prop('checked',$(this).prop('checked'));
	});

	// load previous settings
	var oPromise = getCache('inventoryCols')

		.done(function(aCols){
			aVisibleCols = aCols;
			$(aCols.toString()).prop('checked',true);
			deferred.resolve();
		})

		.fail(function(aCols){
			deferred.resolve();
		})
	;

	return deferred.promise();

}

$('#applyDisplaySelection').click(function () {
if ($('#inventoryLocation').find('input[type=checkbox]:checked').prop('id') == 'showInventoryLocationTable') {
$('#rareList').find('.locationLink').text('(hide)').parent().children('.locationTable').show();
}
else {
$('#rareList').find('.locationLink').text('(show)').parent().children('.locationTable').hide();
}
})



$('#applyColSelection').click(function(){


	var aSelected = [];

	$('input[name=viewProps]:checked').each(function(idx,item){
		aSelected.push('#' + $(item).attr('id'));
	});
	$('input[name=viewMods]:checked').each(function(idx,item){
		aSelected.push('#' + $(item).attr('id'));
	});
	$('input[name=viewCalc]:checked').each(function(idx,item){
		aSelected.push('#' + $(item).attr('id'));
	});
	$('input[name=viewReq]:checked').each(function(idx,item){
		aSelected.push('#' + $(item).attr('id'));
	});

	aVisibleCols = aSelected;
	setCache('inventoryCols',aSelected);

	$('#rareList').empty().append( formatRareList(getSortedItems(aInventory),false) ).find('table').tablesorter();

	$('#openRareList').trigger('click');

})

$('#applyItemSelection').click(function(){

	$('#rareList').empty().append( formatRareList(getSortedItems(aInventory),false) ).find('table').tablesorter();
	$('#openRareList').trigger('click');

})

$('#applyIgnoreLocations').click(function(){

	renderCrafting(aInventory);
	$(lastView).trigger('click');

});

function getCraftingIgnores(){
	var aIgnoreTabs =[];
	var aIgnoreChars =[];

	$('input[name=ignoreTabs]:checked').each(function(idx,item){
		aIgnoreTabs.push(parseInt($(item).val(),10));
	});

	$('input[name=ignoreChars]:checked').each(function(idx,item){
		aIgnoreChars.push($(item).val());
	});

	return {chars: aIgnoreChars, tabs:aIgnoreTabs };
}


function getCraftingItems(items){

	craftItems = [];

	var oIgnore = getCraftingIgnores();

	$.map(items,function(item){
		if(item.location.section === 'stash' && oIgnore.tabs.indexOf(item.location.tabIndex) === -1) {
			craftItems.push(item);
		} else if (item.location.page === 'Inventory' && oIgnore.chars.indexOf(item.location.section) === -1) {
			craftItems.push(item);
		}
	});

	return craftItems;
}

function renderCrafting(items) {

	try {

		var matches = allMatches(getCraftingItems(items));

		var idx = 0;
		var item = {};
		var match = {};

		$('ul#craftingTabs,div#crafting-content').empty();

		for (var item in matches) {
			idx++;

			// add navigation entry
			$('ul#craftingTabs').append('<li class="crafting-page"><a data-index="' + idx + '">' + item + ' (' + matches[item].length + ')</a></li>');

			// add content div
			var oDiv = $('<div class="hide crafting-block" data-index="' + idx + '">');

			// add title
			oDiv.append('<h2>' + item + '</h2>');

			var oTable = $('<table class="table table-striped table-condensed"><thead><tr><th class="type-int">%<th>Matched</th><th>Missing</th><thead></table>');

			var oTBody = $('<tbody>').appendTo(oTable);

			var match_group = matches[item];

			for (var i = 0; i < match_group.length; i++) {
				match = match_group[i];
				// calculate the distance between each item (in tabs, 0 for inventory)
				var distance = 0;
				var last_node = 0;
				for (var j = 0; j < match.items.length; j++) {
					if (last_node === 0) last_node = match.items[j].location.tabIndex;
					if(match.items[j].location.tabIndex !== 0) {
						distance += Math.abs(match.items[j].location.tabIndex - last_node);
						last_node = match.items[j].location.tabIndex
					}
				}
				match.distance = distance;
			}

			// sort on distance
			match_group.sort(function(a,b) {
				// % - distance - closest first item to start
				if (b.complete == a.complete){
					if (a.distance == b.distance) {
						return a.items[0].location.tabIndex - b.items[0].location.tabIndex;
					}
					return a.distance - b.distance;
				}
				return b.complete - a.complete;
			});


			for (var i = 0; i < match_group.length; i++) {
				match = match_group[i];
				$('<tr>')
					.append('<td>' + parseInt(match.complete * 10000) / 100 + '%</td>')
					.append($('<td>').append(getItemsUL(match.items)))
					.append('<td>' + ((match.complete < 1 && match.missing != null) ? match.missing.join('<br>') : '') + '</td>')
					.appendTo(oTBody)
				;
			}

			oDiv.append(oTable);

			// sort crafting tabs
			$('div#crafting-content').append(oDiv);

		}

		sortUL('#craftingTabs');

		$('ul#craftingTabs')
			.append('<li class="divider"></li><li><a id="openCraftingFilters" data-toggle="modal" href="#craftingFilters">Configure Crafting</a></li>')
			.append('<li class="divider"></li><li><a id="saveCraftItems">Export to File</a></li>')

		$('ul#craftingTabs li.crafting-page a').click(function(){
			$('#rareList').hide();
			$('div#crafting-content div.crafting-block').hide();
			$('#menu2, #menu3, ul#craftingTabs li').removeClass('active');
			$(this).parent().addClass('active');
			$(this).closest('.dropdown').addClass('active');
			$('div#crafting-content div[data-index=' + $(this).data('index') + ']').show();
			lastView = 'ul#craftingTabs li.crafting-page a[data-index=' + $(this).data('index') + ']';
			setCache('last-view', lastView);
		});

	} catch (e) {

		// console.log('error occured while processing/rendering crafting matches');
		errorDump(e);

		$('#err').html('An error occured while processing matches in the stash. Please ' +
					   'select refresh then full to try again. If the error persists, contact the author.');

		//console.log('last match item processed');
//	console.log(match);

		//console.log('last match group processed:');
		//console.log(item);

	}



}

function processItems(items){

	var deferred = new $.Deferred();

	// used to rerender the page
	aInventory = items;
			
//		console.log('Processing your items');
	// seems to be used by the clipboard
	currentItems = items;


	$("div.blockMsg").html('<h3>Cached data successfully loaded.</h3><h3>Building table containing ' + items.length + ' item rows... </h3><h4 id="waitOnQueue"></h4>');

	renderCrafting(items);

	setupInventoryRendering(items)
		.done(function(){

			try {

				if (items.length){

					// render rare list
					$('#rareList').append( formatRareList(getSortedItems(items)) ).find('table').tablesorter();

					$('#openRareList')
						.click(function(){
							lastView = '#openRareList';
							setCache('last-view', lastView);

							$('#menu2, #menu3, ul#craftingTabs li').removeClass('active');

							$(this).closest('li.dropdown').addClass('active');
							$('div#crafting-content div.crafting-block').hide();
							$('#rareList').show();
							$(this).parent().addClass('active');
						})
					;

				}

				deferred.resolve();

			} catch (e) {

	//		console.log('error occured while rendering stash');
				errorDump(e);

				$('#err').html('An error occured while rendering the stash. ' +
								'Select refresh then full to try again.');

			}

		})
	;

	return deferred.promise();

}

function errorDump(e) {
	console.log(e);
	if (e.hasOwnProperty('message')) console.log(e.message);
	if (e.hasOwnProperty('stack')) console.log(e.stack);
}


function getLocationTable (item, category) {
	var locationTable = '';

	if (item.location.section == 'stash' || item.location.page == 'Inventory') {
		locationTable = $('<div>').addClass('locationTable');
		var oRaw = item.rawItem;

		var left = oRaw.x;
		var right = left + oRaw.w - 1;
		var top = oRaw.y;
		var bottom = top + oRaw.h - 1;

	if ($('#' + category.toLowerCase() + 'Location').find('input[type=checkbox]:checked').prop('id') == 'show' + category + 'LocationTable') {
locationTable.css('display','table');
}
else {
locationTable.css('display', 'none');
}
	
	
		// if the item is in the stash, draw a 12*12 table
		if (item.location.section == 'stash') {
			height = 12;
		}
		//if it is in the inventory draw a 5*12 table
		else if (item.location.page == 'Inventory') {
			height = 5;
		}

		for (var i = 0; i < height; i++) {
			var row = $('<div>').addClass('locationTableRow');

			for (var j = 0; j < 12; j++) {
				var cell = $('<div>').addClass('locationTableCell');

				if ((j >= left && j <= right) && (i >= top && i <= bottom)) {
					cell.addClass('containsItem');
				}

				row.append(cell);
			}

			locationTable.append(row);
		}
	}

	return locationTable;
}

function getItemsUL(aItems) {

	var oUL = $('<ul class="unstyled">');

	for (var i=0; i < aItems.length; i++) {

		var item = aItems[i];

		var oItem = getItemLink(item);
		var plainLocation = $('<span>').append(' (' + item.location.section + ':' + item.location.page + ') ');


		var thisLI = $('<li>')
			.append(oItem)
			.append(plainLocation)
			
			.append(getLocationTable(item, 'Crafting'))
			.appendTo(oUL)
		;

	}

	return oUL;

}

function getItemLink(item) {

		var oItem = $('<a>')
			.append(item.name)
			.append( item.quality ? ' (' + item.quality + '%)' : '')
			.addClass('item-' + item.rarity)

			.popover({
				//title: item.name,
				html: true,
				trigger: 'hover',
				content: function(){

					var html = $('<div class="fit-content" style="width:500px">');

					var left = $('<div class="pull-left"  style="width:100px">');
					left.append('<img src="' + item.rawItem.icon + '" />');

					var tableContainer = $('<div style="position: absolute; bottom: 25px">');
					var table = getLocationTable(item, "Inventory");
					if(table) table.css('display','table'); // I don't like having to set this again
					// but it's better than making the executive decision
					// to refactor how the tables work in the main table
					tableContainer.append(table);

					left.append(tableContainer);
					html.append(left);

					if (item.sockets.numSockets > 0) {
						html.append(displaySockets(item));
					}

					$('<pre class="pull-left">')
						.append(itemToString(item))
						.appendTo(html);

					$('<div class="clearfix">').appendTo(html);

					return html;
				},
				placement: 'bottom',
				template: '<div class="popover fit-content"><div class="arrow"></div><div class="popover-inner"><div class="popover-content fit-content"><p></p></div></div></div>',
				delay: { show: 500, hide: 100 }
			})
			.click(function(){
				copy_cb(itemToString(item));
				console.log(item);
			})
		;

	return oItem;

}

// TODO (Spacke): adjust this to the new socket/link icons
function displaySockets(item) {

	// Simulate vertical alignment depending on the item type and number of sockets
	var adjustRatio = item.rawItem.h - Math.ceil(item.sockets.numSockets / item.rawItem.w);
	var globalOffsetY = '';
	if (adjustRatio > 0) {
		globalOffsetY = '; margin-top: ' + (adjustRatio * 25) + 'px';
	}

	var sockets = $('<div class="sockets" style="width: ' + parseInt(48 * item.rawItem.w,10) + 'px; height: ' + $('.itemIcon').height() + 'px' + globalOffsetY + '">');
	var icon = {};
	icon['S'] = 'http://www.pathofexile.com/gen/image/YTozOntpOjA7aTo1O2k6/MjthOjI6e3M6Mjoic3Qi/O3M6MDoiIjtzOjY6ImNv/bG91ciI7czoxOiJTIjt9/aToxO2k6NTt9/cba0412822/Socket.png';
	icon['D'] = 'http://www.pathofexile.com/gen/image/YTozOntpOjA7aTo1O2k6/MjthOjI6e3M6Mjoic3Qi/O3M6MDoiIjtzOjY6ImNv/bG91ciI7czoxOiJEIjt9/aToxO2k6NTt9/24adcb67af/Socket.png';
	icon['I'] = 'http://www.pathofexile.com/gen/image/YTozOntpOjA7aTo1O2k6/MjthOjI6e3M6Mjoic3Qi/O3M6MDoiIjtzOjY6ImNv/bG91ciI7czoxOiJJIjt9/aToxO2k6NTt9/b39c59da99/Socket.png';
	var link = {};
	link['H'] = 'http://www.pathofexile.com/gen/image/YTozOntpOjA7aTo1O2k6/MjthOjM6e3M6NDoidHlw/ZSI7czo2OiJzb2NrZXQi/O3M6Mjoic3QiO3M6NDoi/bGluayI7czo0OiJ2ZXJ0/IjtiOjA7fWk6MTtpOjU7/fQ,,/ba11e10fa2/Socket_Link_Horizontal.png';
	link['V'] = 'http://www.pathofexile.com/gen/image/YTozOntpOjA7aTo1O2k6/MjthOjM6e3M6NDoidHlw/ZSI7czo2OiJzb2NrZXQi/O3M6Mjoic3QiO3M6NDoi/bGluayI7czo0OiJ2ZXJ0/IjtiOjE7fWk6MTtpOjU7/fQ,,/3b93f7f851/Socket_Link_Vertical.png';
	var cssPosition = new Array("pull-left", "pull-right", "pull-right", "pull-left", "pull-left", "pull-right");

	// Adjust horizontal alignment for the unique socket on a 2-square width item case
	var globalOffsetX = '';
	if (item.rawItem.w > 1 && item.sockets.numSockets == 1) {
		globalOffsetX = ' style="margin-left: 24px"';
	}

	var activeGroup = 0;
	for (var i = 0; i < item.sockets.numSockets; i++) {
		// Socket
		sockets.append('<img src="' + icon[item.rawItem.sockets[i].attr] + '" alt="" class="' + cssPosition[i] + '"' + globalOffsetX + ' />');

		// Link
		if (item.rawItem.w == 1) {
			// Item width is 1
			if (i == 1 && item.rawItem.sockets[i].group == activeGroup) {
				// 1st vertical link
				sockets.append('<img src="' + link['V'] + '" class="link" style="top: 35px; left: 15px" />');
			}
			if (i == 2 && item.rawItem.sockets[i].group == activeGroup) {
				// 2nd vertical link
				sockets.append('<img src="' + link['V'] + '" class="link" style="top: 83px; left: 15px" />');
			}
		} else {
			// Item width is 2
			if (i == 1 && item.rawItem.sockets[i].group == activeGroup) {
				// 1st horizontal link
				sockets.append('<img src="' + link['H'] + '" class="link" style="top: 15px; left: 35px" />');
			}
			if (i == 2 && item.rawItem.sockets[i].group == activeGroup) {
				// 1st vertical link (right)
				sockets.append('<img src="' + link['V'] + '" class="link" style="top: 35px; left: 63px" />');
			}
			if (i == 3 && item.rawItem.sockets[i].group == activeGroup) {
				// 2nd horizontal link
				sockets.append('<img src="' + link['H'] + '" class="link" style="top: 63px; left: 35px" />');
			}
			if (i == 4 && item.rawItem.sockets[i].group == activeGroup) {
				// 2nd vertical link (left)
				sockets.append('<img src="' + link['V'] + '" class="link" style="top: 83px; left: 15px" />');
			}
			if (i == 5 && item.rawItem.sockets[i].group == activeGroup) {
				// 3nd horizontal link
				sockets.append('<img src="' + link['H'] + '" class="link" style="top: 111px; left: 35px" />');
			}
		}

		activeGroup = item.rawItem.sockets[i].group;
	}

	return sockets;
}

function itemToString(item) {

	var oRaw = item.rawItem;
	var sItem = '';
	sItem += 'Rarity: ' + capitaliseFirstLetter(item.rarity) + '\n';
	sItem += oRaw.name + '\n';
	sItem += oRaw.typeLine + '\n';


	if (oRaw.hasOwnProperty('properties')) {
		sItem += '--------\n';
		for (var i = 0; i < oRaw.properties.length; i++) {
			var oThis = oRaw.properties[i];
			sItem += oThis.name;
			if (oThis.values.length > 0) {

				// find out if the prop is elemental damage, because then there could be more values
				if (oThis.name == "Elemental Damage") {
					sItem += ": ";
					for (var j = 0; j < oThis.values.length; j++) {

						// add the value of the damage
						sItem += oThis.values[j][0];

						// add the type of the elemental damage
						switch (oThis.values[j][1]) {
							case 4: sItem += ' (fire)'; break;
							case 5: sItem += ' (cold)'; break;
							case 6: sItem += ' (lightning)'; break;
							default: sItem += ''; break;
						}

						// skip the last comma
						if (j < oThis.values.length - 1) sItem += ", ";
					}
				}
				else {
					sItem += ": " + oThis.values[0][0];
				}
			}
			if(oThis.augmented) sItem += ' (augmented)';
			sItem += '\n';
		}
	}

	if (oRaw.hasOwnProperty('implicitMods')) {
		sItem += '--------\n';
		for (var i = 0; i < oRaw.implicitMods.length; i++) {
			sItem += oRaw.implicitMods[i] + '\n';
		}
	}

	if (oRaw.hasOwnProperty('requirements')) {
		sItem += '--------\n';
		for (var i = 0; i < oRaw.requirements.length; i++) {
			var oThis = oRaw.requirements[i];
			sItem += oThis.name + ': ' + oThis.values[0][0] + '\n';
		}
	}

	if (oRaw.hasOwnProperty('explicitMods')) {
		sItem += '--------\n';
		for (var i = 0; i < oRaw.explicitMods.length; i++) {
			sItem += oRaw.explicitMods[i] + '\n';
		}
	}

	if (oRaw.hasOwnProperty('flavourText')) {
		sItem += '--------\n';
		for (var i = 0; i < oRaw.flavourText.length; i++) {
			sItem += oRaw.flavourText[i] + '\n';
		}
	}

	return sItem;

}

function formatRareListPlain(sortedRares, separators) {
	var count = sortedRares.length;
	var out = '';
	var prevForename = null;
	for (var i = 0; i < count; ++i) {
		var rareName = sortedRares[i].name;
		if(separators) {
			var forename = rareName.substring(0, rareName.indexOf(' '));
			if(prevForename!=null && prevForename!=forename) {
				// new row
				out+='---------------\n';
			}
			prevForename = forename;
		}
		out += rareName +'\n';
	}
	return out;
}
function getLocationLink (item, category) {
var locationLink = '';
if (item.location.section == 'stash' || item.location.page == 'Inventory') {
locationLink = $('<a>')
.append('(show)')
.addClass('locationLink')
.on('click', function(){
$(this).parent().children('.locationTable').toggle();
if ($(this).text() == '(show)') {
$(this).text('(hide)');
}
else {
$(this).text('(show)');
}
})
;

// check if the table shall be initially displayed
if ($('#' + category.toLowerCase() + 'Location').find('input[type=checkbox]:checked').prop('id') == 'show' + category + 'LocationTable') {
locationLink.text('(hide)');
}
}
return locationLink;
}

function formatRareList(sortedRares, bSetupDropdown) {


	var oTypes = {};

	var oRarity = {};

	var oTable = $('<table class="table table-condensed table-striped">');

	var oHead = $('<thead>');

	var oBody = $('<tbody>');

	var oView = {
		props: [],
		mods: [],
		calculated: [],
		reqs: []
	};

	$('input[name=viewProps]:checked').each(function(idx,item){
		oView.props.push($(item).val());
	});

	$('input[name=viewMods]:checked').each(function(idx,item){
		oView.mods.push($(item).val());
	});

	$('input[name=viewCalc]:checked').each(function(idx,item){
		oView.calculated.push($(item).val());
	});

	$('input[name=viewReq]:checked').each(function(idx,item){
		oView.reqs.push($(item).val());
	});

	var j = 0;

	for (var i = 0; i < sortedRares.length; ++i) {

		var item = sortedRares[i];

		var oRaw = item.rawItem;

		var oItem = getItemLink(item);
		var plainLocation = $('<span>').append('(' + item.location.section + ':' + item.location.page + ') ');

		var tr = $('<tr>')
			.addClass(oTypes[item.itemRealType])
			.addClass(oRarity[item.rarity])
			.append( $('<td style="white-space: nowrap;">').text(  (item.location.section === 'stash' ? currentLeague : item.location.section)  + ' ' + (item.location.page === null ? 0 : item.location.page)))
			.append( $('<td>').append(getLocationLink(item, 'Inventory')).append(getLocationTable(item, 'Inventory')))
			.append( $('<td style="text-align:center;width:35px">').append('<img src="' + item.rawItem.icon + '" style="max-height: 25px;max-width:30px" />'))
			.append( $('<td>').append( getItemLink(item) ))
		;


		for (j = 0; j < oView.props.length; j++) {
			tr.append( $('<td>').text( item.properties.hasOwnProperty(oView.props[j]) ? item.properties[oView.props[j]] : '' ) );
		}
		for (j = 0; j < oView.mods.length; j++) {
			tr.append( $('<td>').text( item.combinedMods.hasOwnProperty(oView.mods[j]) ? item.combinedMods[oView.mods[j]] : '' ) );
		}
		for (j = 0; j < oView.calculated.length; j++) {
			tr.append( $('<td>').text( item.calculated.hasOwnProperty(oView.calculated[j]) ? item.calculated[oView.calculated[j]] : '' ) );
		}
		for (j = 0; j < oView.reqs.length; j++) {
			tr.append( $('<td>').text( item.requirements.hasOwnProperty(oView.reqs[j]) ? item.requirements[oView.reqs[j]] : '' ) );
		}

		tr.appendTo(oBody);
	}

	var th = $('<tr>')
			.append( $('<th class="filter-false">').text('Tab') )
		.append( $('<th class="filter-false">').text('Location') )
		.append( $('<th class="filter-false" style="width:35px;">').text('Image') )
		.append( $('<th class="type-string">').text('Item') )
	;

	for (j = 0; j < oView.props.length; j++) {
		if (oView.props[j] === 'Base Type') {
			th.append( $('<th class="type-string filter-select">').text(oView.props[j]) );
		} else {
	if (oView.props[j] === 'Category') {
			
			th.append( $('<th class="type-string filter-select">').text(oView.props[j]) );
		}
		else
			{
			th.append( $('<th class="type-float">').text(oView.props[j]) );
			}
		}
	}
	for (j = 0; j < oView.mods.length; j++) {
		th.append( $('<th class="type-int">').text(oView.mods[j]) );
	}
	for (j = 0; j < oView.calculated.length; j++) {
		th.append( $('<th class="type-float">').text(oView.calculated[j]) );
	}
	for (j = 0; j < oView.reqs.length; j++) {
		th.append( $('<th class="type-int">').text(oView.reqs[j]) );
	}

	th.appendTo(oHead);

	oTable
		.append(oHead)
		.append(oBody)
	;

	return oTable;
}

function getSortedItems(items) {

	var sortedRares = [];
	var oRarity = {};
	var oType = {};

	var min = parseInt($('#inventoryMinLevel').val(),10);
	var max = parseInt($('#inventoryMaxLevel').val(),10);

	if (isNaN(min)) min = 0;
	if (isNaN(max)) max = 100;


	$('input[name=viewRarity]:checked').each(function(idx,item){
		oRarity[$(item).val()] = true;
	});

	$('input[name=viewType]:checked').each(function(idx,item){
		oType[$(item).val()] = true;
	});

	for (var i = 0; i < items.length; i++) {
		var oThis = items[i];
		var thisLevel = oThis.requirements.hasOwnProperty('Level') ? parseInt(oThis.requirements.Level,10) : 0;

		if (thisLevel <= max && thisLevel >= min && oRarity[oThis.rarity] === true && oType[oThis.itemRealType] === true ) sortedRares.push(oThis);
	}

	// sort on rare name
	sortedRares.sort(function(a,b) {
		if(a.rareName<b.name) {
			return -1;
		}
		else if(a.name>b.name) {
			return 1;
		}
		return 0;
	});

	return sortedRares;

}


function getSortedRares(items) {
	var available = getCraftingItems(items);

	var rares = available.filter(function(i) {
		return (i.rarity == 'rare') && i.identified;
	});

	var sortedRares = rares.sort(function(a,b) {
		if(a.rareName<b.rareName) {
			return -1;
		}
		else if(a.rareName>b.rareName) {
			return 1;
		}
		return 0;
	});

	return sortedRares;

}


function copy_cb(str) {

	var oTemp = $('<textarea>').appendTo('body').val(str).select();
	var foo = document.execCommand('copy');
	oTemp.remove();

}

function paste_cb() {
	var oTemp = $('<textarea>').val('').appendTo('body').select();
	document.execCommand('paste');
	var sRet = oTemp.val();
	oTemp.remove();
	return sRet;
}


$(function(){


	$('#copyItemCSV').click(function(){
		copy_cb($('#rareList').tableExport({output:'csv'}));
	});



	$('#copyToClipboard').click(function () {
		if(currentItems!=null) {
			copy_cb(formatRareListPlain(getSortedRares(currentItems),true));
		}
	});

	$('#copyFromClipboard').click(function () {

		if(currentItems!=null) {

			var theirData = paste_cb();
			// split by line
			var theirLines = theirData.split('\n');

			// apply a regex to find the rare names (of the form "forename surname") on each line.
			// this is quite tolerant of junk on the line. So long as the rare's name is the first word pair on the line, it'll find it.
			var regexedLines = theirLines.map(function(i) {
				var match = i.match(/\w+\s\w+/);
				return match==null?null:match[0];
			});
			// remove any lines that were not matched by the regex above.
			var theirRares = regexedLines.filter(function(i) {
				return i!=null;
			});

			// sort them into descending alphabetical order to make the comparison more efficient
			theirRares.sort(function(a,b) {
				if(a<b) {
					return -1;
				}
				else if(a>b) {
					return 1;
				}
				return 0;
			});

			// get the names of our rares.
			var ourRareItems = getSortedRares(currentItems);

			var matches = [];

			var theirIndex = 0;
			for (var i = 0; i < ourRareItems.length; i++) {
				var ourRare = ourRareItems[i].rareName;
				while(theirIndex<theirRares.length && theirRares[theirIndex]<ourRare) {
					//iterate through until we reach one of their rares that matches, or is alphabetically beyond our rare.
					theirIndex++;
				}

				if(theirIndex==theirRares.length) {
					// reached the end of their Rares,
					// there cannot be any further matches, as there's nothing more to check.
					break;
				}

				var theirCount = 0;
				var theirIndex2 = theirIndex;
				while(theirIndex2<theirRares.length && theirRares[theirIndex2++]==ourRare) {
					// for added usefulness we count the number of their instances that match ours.
					theirCount++;
				}

				if(theirCount>0) {
					// take a (shallow) copy of the rare items that match
					var ourRareItemCopy = $.extend({}, ourRareItems[i]);
					// so that a new attribute can be added.
					ourRareItemCopy.theirCount = theirCount;
					matches.push(ourRareItemCopy);
				}
			}

			var html = '';

			if(matches.length==0) {
				html = "<h4>No matches found</h4>";
			} else {

				copy_cb(formatRareListPlain(matches),false);
				// output the matches here
				html = formatRareList(matches,false);

			}

			$('#clipboardMatch .modal-body').empty().html(html).find('table').tablesorter();

			$('#clipboardMatch').modal('show');
		}
	});


});


function saveItems(fn, items) {

    var aItems = [];

    $.each(items,function(idx,item){
        aItems.push({rawItem: item.rawItem, location:item.location});
    });

    window.webkitRequestFileSystem(window.TEMPORARY, 1024*1024, function(fs) {
        fs.root.getFile(fn, {create: true}, function(fileEntry) {
            fileEntry.createWriter(function(fileWriter) {


                var blob = new Blob([JSON.stringify(aItems)]);

                fileWriter.addEventListener("writeend", function() {
                    // navigate to file, will download
                    location.href = fileEntry.toURL();
                }, false);

                fileWriter.write(blob);
            }, function() {});
        }, function() {});
    }, function() {});

}


  function handleFileSelect(evt) {

    evt.stopPropagation();
    evt.preventDefault();

    // they can drop as many as they like but we're only reading the first file :p
    var file = evt.dataTransfer.files[0];

    var reader = new FileReader();

    reader.onload = function(e) {

        var items = JSON.parse(e.target.result);

        if (items && items.length) {

            currentLeague = 'Imported';

            $('#menuLeague')
                .find('.active').removeClass('active').end()
                .find('a.dropdown-toggle').html(currentLeague + '<b class="caret"></b>').end()
            ;

            resetView();

            var aItems = [];

            $.each(items,function(idx,item){
                aItems.push(parseItem(item.rawItem, item.location));
            });


            processItems(aItems)
                .done(function(){
                    $(lastView).trigger('click');
                })
            ;
        }

    };

    reader.readAsText(file);
  }

  function handleDragOver(evt) {
    evt.stopPropagation();
    evt.preventDefault();
    evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
  }

// Setup the dnd listeners.
var dropZone = document.getElementById('bodycontainer');
dropZone.addEventListener('dragover', handleDragOver, false);
dropZone.addEventListener('drop', handleFileSelect, false);





$('#saveAllItems').click(function(){
    saveItems('inventory.bin',aInventory);
});

$('#saveCraftItems').on('click',function(){
    saveItems('inventory.bin',craftItems);
});


function fileError(e) {
    console.log('filesystem error');
    errorDump(e);
}


